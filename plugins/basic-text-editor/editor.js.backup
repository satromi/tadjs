/**
 * 基本文章編集プラグイン
 * TADファイルをリッチテキストエディタで編集
 */

class BasicTextEditor {
    constructor() {
        this.editor = document.getElementById('editor');
        this.currentFile = null;
        this.tadData = null;
        this.isFullscreen = false;
        this.wrapMode = true;
        this.viewMode = 'formatted'; // 'formatted' or 'xml'
        this.dialogMessageId = 0; // ダイアログメッセージID
        this.fileId = null; // 実身ID
        this.isModified = false; // 編集状態フラグ
        this.originalContent = ''; // 保存時の内容

        this.init();
    }

    init() {
        // デフォルトの折り返しスタイルを設定
        this.editor.style.whiteSpace = 'pre-wrap';
        this.editor.style.wordWrap = 'break-word';

        this.setupEventListeners();
        this.setupContextMenu();
        this.setupWindowActivation();

        // 親ウィンドウからのメッセージを受信
        window.addEventListener('message', (event) => {
            console.log('[EDITOR] メッセージ受信:', event.data);
            console.log('[EDITOR] event.data.type:', event.data ? event.data.type : 'undefined');

            if (event.data && event.data.type === 'init') {
                console.log('[EDITOR] init受信');
                console.log('[EDITOR] fileData:', event.data.fileData);
                console.log('[EDITOR] fileData.xmlData exists:', !!(event.data.fileData && event.data.fileData.xmlData));
                console.log('[EDITOR] fileData.xmlData length:', event.data.fileData && event.data.fileData.xmlData ? event.data.fileData.xmlData.length : 0);

                // fileIdを保存（拡張子を除去）
                if (event.data.fileData) {
                    let rawId = event.data.fileData.realId || event.data.fileData.fileId;
                    this.fileId = rawId ? rawId.replace(/_\d+\.xtad$/, '') : null;
                    console.log('[EDITOR] fileId設定:', this.fileId, '(元:', rawId, ')');
                }

                this.loadFile(event.data.fileData);
            } else if (event.data && event.data.type === 'window-moved') {
                // ウィンドウ移動終了時にwindowConfigを更新
                this.updateWindowConfig({
                    pos: event.data.pos,
                    width: event.data.width,
                    height: event.data.height
                });
            } else if (event.data && event.data.type === 'window-resized-end') {
                // ウィンドウリサイズ終了時にwindowConfigを更新
                this.updateWindowConfig({
                    pos: event.data.pos,
                    width: event.data.width,
                    height: event.data.height
                });
            } else if (event.data && event.data.type === 'window-maximize-toggled') {
                // 全画面表示切り替え時にwindowConfigを更新
                this.updateWindowConfig({
                    pos: event.data.pos,
                    width: event.data.width,
                    height: event.data.height,
                    maximize: event.data.maximize
                });
            } else if (event.data && event.data.type === 'menu-action') {
                console.log('[EDITOR] menu-action受信:', event.data.action);
                this.executeMenuAction(event.data.action, event.data.additionalData);
            } else if (event.data && event.data.type === 'get-menu-definition') {
                console.log('[EDITOR] get-menu-definition受信');
                // メニュー定義を親ウィンドウに返送
                this.getMenuDefinition().then(menuDefinition => {
                    window.parent.postMessage({
                        type: 'menu-definition-response',
                        messageId: event.data.messageId,
                        menuDefinition: menuDefinition
                    }, '*');
                });
            } else if (event.data && event.data.type === 'input-dialog-response') {
                // ダイアログレスポンスを処理
                if (this.dialogCallbacks && this.dialogCallbacks[event.data.messageId]) {
                    this.dialogCallbacks[event.data.messageId](event.data.result);
                    delete this.dialogCallbacks[event.data.messageId];
                }
            } else if (event.data && event.data.type === 'message-dialog-response') {
                // メッセージダイアログレスポンスを処理
                if (this.dialogCallbacks && this.dialogCallbacks[event.data.messageId]) {
                    this.dialogCallbacks[event.data.messageId](event.data.result);
                    delete this.dialogCallbacks[event.data.messageId];
                }
            } else if (event.data && event.data.type === 'window-close-request') {
                // ウィンドウクローズ要求を処理
                this.handleCloseRequest(event.data.windowId);
            }
        });

        // ダイアログコールバック管理
        this.dialogCallbacks = {};

        console.log('[基本文章編集] 準備完了');
    }

    setupEventListeners() {
        // キーボードショートカット
        this.editor.addEventListener('keydown', (e) => {
            this.handleKeyboardShortcuts(e);
        });

        // コンテンツ変更時に高さを更新（入力、削除、貼り付けなど）
        this.editor.addEventListener('input', () => {
            this.updateContentHeight();
            // 編集状態を記録
            this.isModified = true;
        });

        // DOMの変更も監視（delete、backspaceなど）
        const observer = new MutationObserver(() => {
            this.updateContentHeight();
        });
        observer.observe(this.editor, {
            childList: true,
            subtree: true,
            characterData: true
        });

        // クリックイベントで親ウィンドウのコンテキストメニューを閉じる
        document.addEventListener('click', (e) => {
            // 親ウィンドウにメニューを閉じる要求を送信
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'close-context-menu'
                }, '*');
            }
        });

        // コピーイベント: 仮身を含む場合はXML形式でコピー
        this.editor.addEventListener('copy', (e) => {
            this.handleCopy(e);
        });

        // 初期高さを設定
        setTimeout(() => this.updateContentHeight(), 100);

        // ドラッグ&ドロップイベント
        this.setupDragAndDrop();
    }

    /**
     * ドラッグ&ドロップ機能を設定
     */
    setupDragAndDrop() {
        // ドラッグオーバー
        this.editor.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            this.editor.style.backgroundColor = '#e8f4f8';
        });

        // ドラッグリーブ
        this.editor.addEventListener('dragleave', (e) => {
            e.preventDefault();
            this.editor.style.backgroundColor = '';
        });

        // ドロップ
        this.editor.addEventListener('drop', (e) => {
            e.preventDefault();
            this.editor.style.backgroundColor = '';

            try {
                const data = e.dataTransfer.getData('text/plain');
                if (data) {
                    // JSON形式かどうかチェック
                    try {
                        const dragData = JSON.parse(data);

                        if (dragData.type === 'base-file-copy' && dragData.source === 'base-file-manager') {
                            // 原紙管理からのコピー
                            this.insertBaseFileContent(dragData.baseFile);
                            return; // 処理完了
                        } else if (dragData.type === 'archive-file-extract' && dragData.source === 'unpack-file') {
                            // 書庫管理からのファイル展開
                            this.extractArchiveFile(dragData.file, dragData.fileIdMap);
                            return; // 処理完了
                        } else if (dragData.type === 'virtual-object-drag' && dragData.source === 'virtual-object-list') {
                            // 仮身一覧からの仮身ドロップ
                            console.log('[EDITOR] 仮身ドロップ受信:', dragData.virtualObject.link_name);
                            this.insertVirtualObjectLink(dragData.virtualObject);
                            return; // 処理完了
                        }
                    } catch (_jsonError) {
                        // JSON形式でない場合は通常のテキストとして扱う
                        console.log('[EDITOR] 通常のテキストドロップ');
                    }

                    // 通常のテキストドロップの場合は、デフォルト動作を許可
                    // （ブラウザのデフォルトテキスト挿入が動作する）
                }
            } catch (error) {
                console.error('[EDITOR] ドロップ処理エラー:', error);
            }
        });
    }

    /**
     * コピーイベントハンドラ: 仮身を含む場合はXML形式でコピー
     */
    handleCopy(e) {
        try {
            const selection = window.getSelection();
            if (!selection.rangeCount) {
                return; // 選択範囲がない場合はデフォルト動作
            }

            const range = selection.getRangeAt(0);
            const container = range.cloneContents();

            // 選択範囲に仮身が含まれているか確認
            const hasVirtualObject = container.querySelector('.virtual-object') !== null;

            if (!hasVirtualObject) {
                // 仮身が含まれていない場合はデフォルト動作
                return;
            }

            // デフォルト動作を防止
            e.preventDefault();

            // 一時的なコンテナを作成してHTMLからXMLに変換
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(container);

            // XMLに変換
            const xmlContent = this.extractTADXMLFromElement(tempDiv);

            // プレーンテキスト版も作成（仮身は名前のみ）
            const plainText = tempDiv.textContent;

            console.log('[EDITOR] コピー内容（XML）:', xmlContent);
            console.log('[EDITOR] コピー内容（プレーンテキスト）:', plainText);

            // クリップボードに両方の形式でコピー
            e.clipboardData.setData('text/plain', plainText);
            e.clipboardData.setData('text/html', xmlContent);
            e.clipboardData.setData('application/x-tad-xml', xmlContent);

            this.setStatus('クリップボードへコピーしました（仮身を含む）');
        } catch (error) {
            console.error('[EDITOR] コピーエラー:', error);
            // エラー時はデフォルト動作を許可
        }
    }

    /**
     * 原紙ファイルの内容を挿入
     */
    insertBaseFileContent(baseFile) {
        console.log('[EDITOR] 原紙ファイル挿入:', baseFile.displayName);

        // XMLデータをHTMLに変換して挿入
        if (baseFile.xmlData) {
            const htmlContent = this.renderTADXML(baseFile.xmlData);

            // カーソル位置に挿入
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                range.deleteContents();

                const fragment = document.createRange().createContextualFragment(htmlContent);
                range.insertNode(fragment);
            } else {
                // カーソル位置がない場合は末尾に追加
                this.editor.innerHTML += htmlContent;
            }

            this.updateContentHeight();
            console.log('[EDITOR] 原紙ファイル挿入完了');
        }
    }

    /**
     * 仮身リンクを挿入
     * @param {Object} virtualObject - 仮身オブジェクト
     */
    insertVirtualObjectLink(virtualObject) {
        console.log('[EDITOR] 仮身リンク挿入:', virtualObject.link_name);

        // 仮身要素を作成
        const vobjElement = document.createElement('span');
        vobjElement.className = 'virtual-object';
        vobjElement.textContent = virtualObject.link_name;
        vobjElement.setAttribute('data-link-id', virtualObject.link_id);
        vobjElement.setAttribute('data-applist', JSON.stringify(virtualObject.applist || {}));
        vobjElement.style.display = 'inline-block';
        vobjElement.style.padding = '4px 8px';
        vobjElement.style.margin = '0 2px';
        vobjElement.style.background = virtualObject.tbcol || '#e3f2fd';
        vobjElement.style.border = `1px solid ${virtualObject.frcol || '#64b5f6'}`;
        vobjElement.style.borderRadius = '4px';
        vobjElement.style.cursor = 'pointer';
        vobjElement.style.fontSize = '0.9em';
        vobjElement.style.color = virtualObject.chcol || '#000000';
        vobjElement.style.verticalAlign = 'middle';

        // クリックイベント
        vobjElement.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('[EDITOR] 仮身クリック:', virtualObject.link_name);
            this.openVirtualObject(virtualObject);
        });

        // 右クリックメニュー用にコンテキストを保存
        vobjElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.contextMenuVirtualObject = {
                virtualObj: virtualObject,
                element: vobjElement
            };

            // 親ウィンドウにコンテキストメニューを要求
            if (window.parent && window.parent !== window) {
                const rect = window.frameElement.getBoundingClientRect();
                window.parent.postMessage({
                    type: 'context-menu-request',
                    x: rect.left + e.clientX,
                    y: rect.top + e.clientY
                }, '*');
            }
        });

        // カーソル位置に挿入
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            range.deleteContents();
            range.insertNode(vobjElement);

            // カーソルを仮身の後ろに移動
            range.setStartAfter(vobjElement);
            range.setEndAfter(vobjElement);
            selection.removeAllRanges();
            selection.addRange(range);
        } else {
            // カーソル位置がない場合は末尾に追加
            this.editor.appendChild(vobjElement);
        }

        this.updateContentHeight();
        console.log('[EDITOR] 仮身リンク挿入完了');
    }

    /**
     * 仮身を開く
     * @param {Object} virtualObject - 仮身オブジェクト
     */
    openVirtualObject(virtualObject) {
        console.log('[EDITOR] 仮身を開く:', virtualObject.link_name, virtualObject.link_id);

        // 親ウィンドウにメッセージを送信して仮身リンク先を開く
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'open-virtual-object-real',
                virtualObj: virtualObject,
                pluginId: null // デフォルトプラグインで開く
            }, '*');
        }
    }

    /**
     * 書庫ファイルを展開して.xtadファイルとして生成
     */
    async extractArchiveFile(file, fileIdMap) {
        console.log('[EDITOR] 書庫ファイル展開:', file.name);

        try {
            // fileオブジェクトから直接XMLデータを取得
            const xmlData = file.xmlData;

            if (xmlData) {
                // ファイル名を生成: UUID_recordIndex.xtad
                const filename = `${file.fileId}_${file.recordIndex}.xtad`;

                // .xtadファイルとしてダウンロード
                this.downloadAsXtad(xmlData, filename);

                console.log(`[EDITOR] ファイル生成: ${filename}`);
            } else {
                console.error('[EDITOR] XMLデータの取得に失敗 - fileオブジェクトにxmlDataが含まれていません');
                console.log('[EDITOR] fileオブジェクト:', file);
            }

        } catch (error) {
            console.error('[EDITOR] 書庫ファイル展開エラー:', error);
        }
    }

    /**
     * XMLデータを.xtadファイルとしてダウンロード
     */
    downloadAsXtad(xmlData, filename) {
        const blob = new Blob([xmlData], { type: 'application/xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    updateContentHeight() {
        // .plugin-contentのサイズを取得（より正確）
        const pluginContent = document.querySelector('.plugin-content');
        if (!pluginContent) return;

        const contentHeight = pluginContent.scrollHeight;
        const contentWidth = pluginContent.scrollWidth;

        // 親ウィンドウに高さと幅の変更を通知
        if (window.parent && window.parent !== window) {
            const message = {
                type: 'content-size-changed',
                height: contentHeight
            };

            // 折り返しOFFの時のみ幅も送信
            if (!this.wrapMode) {
                message.width = contentWidth;
            }

            window.parent.postMessage(message, '*');

            // スクロールバー更新要求を送信
            window.parent.postMessage({
                type: 'update-scrollbars'
            }, '*');
        }
    }

    handleKeyboardShortcuts(e) {
        // Shift+Enter または Ctrl+Enter: 改行（<br>）を挿入
        if ((e.shiftKey || e.ctrlKey) && e.key === 'Enter') {
            e.preventDefault();
            // <br>タグを挿入
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const br = document.createElement('br');
                range.deleteContents();
                range.insertNode(br);
                
                // カーソルを<br>の後ろに移動
                range.setStartAfter(br);
                range.setEndAfter(br);
                selection.removeAllRanges();
                selection.addRange(range);
            }
            return;
        }

        // Ctrl+S: 保存（XMLエクスポート）
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            this.exportToXML();
        }

        // Ctrl+B: 太字
        if (e.ctrlKey && e.key === 'b') {
            e.preventDefault();
            document.execCommand('bold');
        }

        // Ctrl+I: 斜体
        if (e.ctrlKey && e.key === 'i') {
            e.preventDefault();
            document.execCommand('italic');
        }

        // Ctrl+U: 下線
        if (e.ctrlKey && e.key === 'u') {
            e.preventDefault();
            document.execCommand('underline');
        }
    }

    /**
     * TADファイルを読み込み
     */
    async loadFile(fileData) {
        try {
            console.log('[EDITOR] loadFile呼び出し, fileData:', fileData);
            this.setStatus('ファイル読み込み中...');
            this.currentFile = fileData;
            this.fileId = fileData ? fileData.realId : null;

            console.log('[EDITOR] fileDataチェック:', {
                hasXmlData: !!fileData.xmlData,
                hasRawData: !!fileData.rawData,
                fileName: fileData.fileName
            });

            // XMLデータが既に渡されている場合
            if (fileData.xmlData) {
                console.log('[EDITOR] XMLデータを使用, 長さ:', fileData.xmlData.length);
                console.log('[EDITOR] XMLプレビュー:', fileData.xmlData.substring(0, 200));

                this.tadData = fileData.xmlData;

                // XMLを解釈してリッチテキストとして表示
                this.renderTADXML(fileData.xmlData);

                this.setStatus(`読み込み完了: ${fileData.fileName} (${fileData.xmlData.length}文字)`);

                // DOM更新後にスクロールバーを更新
                setTimeout(() => this.updateContentHeight(), 0);
            }
            // rawDataがある場合は変換を試みる
            else if (fileData.rawData) {
                console.log('rawDataからXMLに変換中...');
                const xmlData = await this.parseTADToXML(fileData.rawData);
                if (xmlData) {
                    this.tadData = xmlData;
                    this.renderTADXML(xmlData);
                    this.setStatus(`読み込み完了: ${fileData.fileName}`);

                    // DOM更新後にスクロールバーを更新
                    setTimeout(() => this.updateContentHeight(), 0);
                } else {
                    this.editor.innerHTML = '<p>TADファイルの解析に失敗しました</p>';
                    this.setStatus('XMLの生成に失敗しました');
                }
            }
            else {
                // フォールバック: プレーンテキストとして表示
                this.editor.innerHTML = '<p>TADファイルの内容を表示できません</p>';
                this.setStatus('エラー: データ形式が不正です');
            }
        } catch (error) {
            console.error('ファイル読み込みエラー:', error);
            console.error('エラースタック:', error.stack);
            this.editor.innerHTML = '<p>ファイル読み込みエラー</p><pre>' + this.escapeHtml(error.message + '\n' + error.stack) + '</pre>';
            this.setStatus('ファイルの読み込みに失敗しました');
        }
    }

    /**
     * TADファイルをXMLに変換
     */
    async parseTADToXML(rawData) {
        // 親ウィンドウのparseTADToXML関数を使用
        if (window.parent && typeof window.parent.parseTADToXML === 'function') {
            try {
                const uint8Array = rawData instanceof Uint8Array ? rawData : new Uint8Array(rawData);
                const xmlResult = await window.parent.parseTADToXML(uint8Array, 0);
                console.log('XML変換完了:', xmlResult ? xmlResult.substring(0, 100) : 'null');
                return xmlResult;
            } catch (error) {
                console.error('TAD→XML変換エラー:', error);
                return null;
            }
        }
        console.warn('parseTADToXML関数が見つかりません');
        return null;
    }

    /**
     * <link>タグを仮身（Virtual Object）HTMLに変換
     */
    convertLinkTagsToVirtualObjects(content) {
        // <link ...>...</link> タグを検出して仮身に変換（すべての属性を保持）
        const linkRegex = /<link\s+([^>]*)>(.*?)<\/link>/gi;

        return content.replace(linkRegex, (match, attributes, innerContent) => {
            // 属性を解析
            const attrMap = {};
            const attrRegex = /(\w+)="([^"]*)"/g;
            let attrMatch;

            while ((attrMatch = attrRegex.exec(attributes)) !== null) {
                attrMap[attrMatch[1]] = attrMatch[2];
            }

            // data属性として保存（すべての属性を保持）
            let dataAttrs = '';
            for (const [key, value] of Object.entries(attrMap)) {
                const escapedKey = this.escapeHtml(key);
                const escapedValue = this.escapeHtml(value);
                dataAttrs += ` data-link-${escapedKey}="${escapedValue}"`;
            }

            // innerContentも保存（XMLエクスポート時に必要）
            const escapedInnerContent = this.escapeHtml(innerContent.trim());
            dataAttrs += ` data-link-innercontent="${escapedInnerContent}"`;

            // 表示名は<link></link>で囲まれたテキスト（innerContent）を使用
            // innerContentが空の場合はname属性、それもなければidを使用
            const displayName = innerContent.trim() || attrMap.name || attrMap.id || '無題';

            // 仮身の見た目をデータから取得（仮身一覧プラグインと同じスタイル）
            const tbcol = attrMap.tbcol || '#e3f2fd'; // タイトル背景色
            const frcol = attrMap.frcol || '#64b5f6'; // 枠線色
            const chcol = attrMap.chcol || '#000000'; // 文字色

            const style = `display: inline-block; padding: 4px 8px; margin: 0 2px; background: ${tbcol}; border: 1px solid ${frcol}; border-radius: 4px; cursor: pointer; color: ${chcol}; font-size: 0.9em; vertical-align: middle;`;

            return `<span class="virtual-object"${dataAttrs} style="${style}">${this.escapeHtml(displayName)}</span>`;
        });
    }

    /**
     * TAD XML文字修飾タグをHTMLに変換
     */
    convertDecorationTagsToHTML(content) {
        let html = content;

        // 最初に<link>タグを仮身に変換（他の処理で消されないように先に処理）
        html = this.convertLinkTagsToVirtualObjects(html);

        // XMLの改行文字を削除（タグの外側の改行のみ）
        // テキスト内の<br/>は保持
        html = html.replace(/\n/g, '').replace(/\r/g, '');

        // <font>タグを処理（自己閉じタグのペア形式を処理）
        // 状態管理しながらスタック方式で処理
        let result = '';
        let pos = 0;
        const fontRegex = /<font\s+(size|color|face)="([^"]*)"\s*\/>/g;
        let match;
        const stack = [];

        while ((match = fontRegex.exec(html)) !== null) {
            // マッチする前のテキスト・タグを追加
            result += html.substring(pos, match.index);
            
            const attr = match[1]; // size, color, face
            const value = match[2]; // 値

            if (value === '') {
                // 空文字列 = 終了タグ（元に戻す）
                // スタックから対応する開始タグを探して閉じる
                for (let i = stack.length - 1; i >= 0; i--) {
                    if (stack[i].attr === attr) {
                        result += '</span>';
                        stack.splice(i, 1);
                        break;
                    }
                }
            } else {
                // 値あり = 開始タグ
                let styleValue = '';
                if (attr === 'size') {
                    styleValue = `font-size: ${value}pt;`;
                } else if (attr === 'color') {
                    styleValue = `color: ${value};`;
                } else if (attr === 'face') {
                    styleValue = `font-family: ${value};`;
                }
                result += `<span style="${styleValue}">`;
                stack.push({ attr, value });
            }

            pos = fontRegex.lastIndex;
        }

        // 残りのテキストを追加
        result += html.substring(pos);
        html = result;

        // <underline>タグ -> <u>タグ
        html = html.replace(/<underline>(.*?)<\/underline>/gi, '<u>$1</u>');

        // <overline>タグ -> overlineスタイル
        html = html.replace(/<overline>(.*?)<\/overline>/gi, '<span style="text-decoration: overline;">$1</span>');

        // <strikethrough>タグ -> <s>タグ
        html = html.replace(/<strikethrough>(.*?)<\/strikethrough>/gi, '<s>$1</s>');

        // <bold>タグ -> <b>タグ
        html = html.replace(/<bold>(.*?)<\/bold>/gi, '<b>$1</b>');

        // <italic>タグ -> <i>タグ
        html = html.replace(/<italic>(.*?)<\/italic>/gi, '<i>$1</i>');

        // <superscript>タグ -> <sup>タグ
        html = html.replace(/<superscript>(.*?)<\/superscript>/gi, '<sup>$1</sup>');

        // <subscript>タグ -> <sub>タグ
        html = html.replace(/<subscript>(.*?)<\/subscript>/gi, '<sub>$1</sub>');

        // <bagchar>タグ -> text-strokeスタイル（袋文字）
        html = html.replace(/<bagchar>(.*?)<\/bagchar>/gi, '<span style="-webkit-text-stroke: 1px currentColor; paint-order: stroke fill;">$1</span>');

        // <box>タグ -> 枠囲み線（border）
        html = html.replace(/<box>(.*?)<\/box>/gi, '<span style="border: 1px solid currentColor; padding: 0 2px;">$1</span>');

        // <invert>タグ -> 反転スタイル
        html = html.replace(/<invert>(.*?)<\/invert>/gi, '<span style="background-color: currentColor; color: #ffffff; padding: 0 2px;">$1</span>');

        // <mesh>タグ -> 網掛けスタイル（#00000019 = rgba(0,0,0,0.1)相当）
        html = html.replace(/<mesh>(.*?)<\/mesh>/gi, '<span style="background-image: repeating-linear-gradient(45deg, transparent, transparent 2px, #00000019 2px, #00000019 4px);">$1</span>');

        // <noprint>タグ -> 薄い表示（無印字を示唆）
        html = html.replace(/<noprint>(.*?)<\/noprint>/gi, '<span style="opacity: 0.3;" data-noprint="true">$1</span>');

        // <ruby>タグ -> HTMLのrubyタグ
        // position="0"は行戻し側（上）、position="1"は行送り側（下）
        html = html.replace(/<ruby\s+position="([01])"\s+text="([^"]*)"\s*>(.*?)<\/ruby>/gi, (match, position, rubyText, baseText) => {
            if (position === '0') {
                // 上側ルビ（通常のルビ）
                return `<ruby>${baseText}<rt>${rubyText}</rt></ruby>`;
            } else {
                // 下側ルビ（rtcを使用）
                return `<ruby>${baseText}<rtc style="ruby-position: under;">${rubyText}</rtc></ruby>`;
            }
        });

        // <br/>タグを保持
        html = html.replace(/<br\s*\/>/gi, '<br>');

        return html;
    }

    /**
     * TAD XMLから段落要素を抽出
     * <text>タグはレイアウト情報なので無視し、<document>内の<p>タグから直接テキストを抽出
     */
    parseTextElements(tadXML) {
        console.log('[EDITOR] parseTextElements開始');
        const textElements = [];

        // <document>...</document>を抽出
        const docMatch = /<document>([\s\S]*?)<\/document>/i.exec(tadXML);

        if (!docMatch) {
            console.warn('[EDITOR] <document>タグが見つかりません');
            return textElements;
        }

        const docContent = docMatch[1];
        console.log('[EDITOR] <document>内容抽出完了, 長さ:', docContent.length);

        // <p>タグで段落に分割
        const paragraphRegex = /<p>([\s\S]*?)<\/p>/gi;
        let pMatch;
        let paragraphCount = 0;

        while ((pMatch = paragraphRegex.exec(docContent)) !== null) {
            const paragraphContent = pMatch[1];
            paragraphCount++;
            console.log(`[EDITOR] 段落${paragraphCount}:`, paragraphContent.substring(0, 100));

            // <text>タグは無視（レイアウト情報）
            // <font>タグからフォント情報を抽出（自己閉じタグ形式に対応）

            // <font color="..."/> を抽出
            const fontColorMatch = /<font\s+color="([^"]*)"\s*\/>/i.exec(paragraphContent);
            const fontColor = fontColorMatch ? fontColorMatch[1] : '';

            // <font size="..."/> を抽出
            const fontSizeMatch = /<font\s+size="([^"]*)"\s*\/>/i.exec(paragraphContent);
            const fontSize = fontSizeMatch ? fontSizeMatch[1] : '14';

            // <font face="..."/> を抽出（ネストした引用符に対応）
            const fontFaceMatch = /<font\s+face="([^"]*)"\s*\/>/i.exec(paragraphContent);
            const fontFamily = fontFaceMatch ? fontFaceMatch[1] : '';

            // <text align="..."/> を抽出
            const textAlignMatch = /<text\s+align="([^"]*)"\s*\/>/i.exec(paragraphContent);
            const textAlign = textAlignMatch ? textAlignMatch[1] : 'left';

            // 文字修飾タグをHTMLに変換してコンテンツを取得
            const htmlContent = this.convertDecorationTagsToHTML(paragraphContent);

            // タグを除去してテキストのみ抽出（plainText用）
            const plainText = paragraphContent
                .replace(/\r\n/g, '')              // XML整形用の\r\nを先に削除
                .replace(/\r/g, '')                // \rを削除
                .replace(/<text[^>]*>/gi, '')      // <text>開始タグを削除
                .replace(/<\/text>/gi, '')         // </text>を削除
                .replace(/<font[^>]*\/>/gi, '')    // <font>自己閉じタグを削除
                .replace(/<font[^>]*>/gi, '')      // <font>開始タグを削除（後方互換性）
                .replace(/<\/font>/gi, '')         // </font>を削除（後方互換性）
                .replace(/<br\s*\/?>/gi, '\n')     // <br>を改行に変換（これは残す）
                .replace(/<[^>]+>/g, '')           // その他のタグを削除
                .trim();

            if (plainText) {
                console.log(`[EDITOR]   テキスト抽出:`, plainText.substring(0, 50));
                if (fontColor) console.log(`[EDITOR]   カラー: ${fontColor}`);
                if (fontSize !== '14') console.log(`[EDITOR]   サイズ: ${fontSize}pt`);
                if (fontFamily) console.log(`[EDITOR]   フォント: ${fontFamily.substring(0, 30)}`);

                textElements.push({
                    fontSize: fontSize,
                    fontFamily: fontFamily,
                    fontColor: fontColor,
                    textAlign: textAlign,
                    content: plainText,
                    htmlContent: htmlContent,  // HTML変換済みコンテンツ
                    rawXML: paragraphContent  // 元のXMLを保持
                });
            } else {
                // 空の段落も保持（改行として）
                console.log(`[EDITOR]   空段落`);
                textElements.push({
                    fontSize: '14',
                    fontFamily: '',
                    fontColor: '',
                    textAlign: textAlign,
                    content: '',
                    rawXML: paragraphContent  // 元のXMLを保持
                });
            }
        }

        console.log('[EDITOR] parseTextElements完了, 要素数:', textElements.length);
        return textElements;
    }

    /**
     * tadXMLをエディタに描画（TAD XMLタグをそのまま使用）
     */
    renderTADXML(tadXML) {
        if (!tadXML) {
            this.editor.innerHTML = '<p>XMLデータの解析に失敗しました</p>';
            return;
        }

        try {
            console.log('[EDITOR] XML解析開始');

            // <document>...</document>を抽出
            const docMatch = /<document>([\s\S]*?)<\/document>/i.exec(tadXML);
            if (!docMatch) {
                console.warn('[EDITOR] <document>タグが見つかりません');
                this.editor.innerHTML = '<p>Document要素が見つかりません</p>';
                return;
            }

            const docContent = docMatch[1];

            // <p>タグで段落に分割（閉じタグがあるもの）
            const paragraphRegex = /<p>([\s\S]*?)<\/p>/gi;
            let htmlContent = '';
            let pMatch;
            let paragraphCount = 0;
            let lastIndex = 0;

            while ((pMatch = paragraphRegex.exec(docContent)) !== null) {
                paragraphCount++;
                let paragraphContent = pMatch[1];
                lastIndex = paragraphRegex.lastIndex;  // 最後に処理した位置を記録

                console.log(`[EDITOR] 段落${paragraphCount} 元の内容(最初の100文字):`, JSON.stringify(paragraphContent.substring(0, 100)));

                // 段落の前後の空白文字（改行、タブ、スペース）をトリム
                paragraphContent = paragraphContent.trim();

                // <font>と<text>タグから段落レベルのスタイルを抽出
                let style = 'margin: 0.5em 0;';

                // フォントサイズ（段落の最初のもののみ）
                const fontSizeMatch = /<font\s+size="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (fontSizeMatch) {
                    style += `font-size: ${fontSizeMatch[1]}pt;`;
                    paragraphContent = paragraphContent.replace(/<font\s+size="[^"]*"\s*\/>/i, '');
                }

                // フォントファミリー（段落の最初のもののみ）
                const fontFaceMatch = /<font\s+face="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (fontFaceMatch) {
                    style += `font-family: ${fontFaceMatch[1]};`;
                    paragraphContent = paragraphContent.replace(/<font\s+face="[^"]*"\s*\/>/i, '');
                }

                // フォントカラー（段落の最初のもののみ）
                const fontColorMatch = /<font\s+color="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (fontColorMatch) {
                    style += `color: ${fontColorMatch[1]};`;
                    paragraphContent = paragraphContent.replace(/<font\s+color="[^"]*"\s*\/>/i, '');
                }

                // テキスト配置
                const textAlignMatch = /<text\s+align="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (textAlignMatch) {
                    style += `text-align: ${textAlignMatch[1]};`;
                    paragraphContent = paragraphContent.replace(/<text\s+align="[^"]*"\s*\/>/gi, '');
                }

                // その他の<text>タグを削除（レイアウト情報）
                paragraphContent = paragraphContent.replace(/<text[^>]*\/>/gi, '');
                paragraphContent = paragraphContent.replace(/<text[^>]*>/gi, '').replace(/<\/text>/gi, '');

                console.log(`[EDITOR] 段落${paragraphCount} スタイル削除後(最初の100文字):`, JSON.stringify(paragraphContent.substring(0, 100)));

                // タグ間の余分な空白・改行を正規化
                // ただしテキストノード内の空白は保持
                paragraphContent = paragraphContent.replace(/>\s+</g, '><');

                console.log(`[EDITOR] 段落${paragraphCount} 空白正規化後(最初の100文字):`, JSON.stringify(paragraphContent.substring(0, 100)));

                // インライン<font>タグをHTMLに変換
                paragraphContent = this.convertDecorationTagsToHTML(paragraphContent);

                console.log(`[EDITOR] 段落${paragraphCount} HTML変換後(最初の100文字):`, JSON.stringify(paragraphContent.substring(0, 100)));

                // 空の段落（XMLソースの整形による改行のみの段落）はスキップ
                if (paragraphContent.trim()) {
                    htmlContent += `<p style="${style}">${paragraphContent}</p>`;
                }
            }

            // 閉じタグがない残りのコンテンツを処理（最後の<p>タグ以降）
            const remainingContent = docContent.substring(lastIndex);
            const openPMatch = /<p>([\s\S]*)$/i.exec(remainingContent);
            if (openPMatch) {
                paragraphCount++;
                let paragraphContent = openPMatch[1].trim();

                console.log(`[EDITOR] 段落${paragraphCount} (閉じタグなし) 元の内容(最初の100文字):`, JSON.stringify(paragraphContent.substring(0, 100)));

                // 段落レベルのスタイルを抽出
                let style = 'margin: 0.5em 0;';

                // フォントサイズ
                const fontSizeMatch = /<font\s+size="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (fontSizeMatch) {
                    style += `font-size: ${fontSizeMatch[1]}pt;`;
                    paragraphContent = paragraphContent.replace(/<font\s+size="[^"]*"\s*\/>/i, '');
                }

                // フォントファミリー
                const fontFaceMatch = /<font\s+face="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (fontFaceMatch) {
                    style += `font-family: ${fontFaceMatch[1]};`;
                    paragraphContent = paragraphContent.replace(/<font\s+face="[^"]*"\s*\/>/i, '');
                }

                // フォントカラー
                const fontColorMatch = /<font\s+color="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (fontColorMatch) {
                    style += `color: ${fontColorMatch[1]};`;
                    paragraphContent = paragraphContent.replace(/<font\s+color="[^"]*"\s*\/>/i, '');
                }

                // テキスト配置
                const textAlignMatch = /<text\s+align="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (textAlignMatch) {
                    style += `text-align: ${textAlignMatch[1]};`;
                    paragraphContent = paragraphContent.replace(/<text\s+align="[^"]*"\s*\/>/gi, '');
                }

                // その他の<text>タグを削除
                paragraphContent = paragraphContent.replace(/<text[^>]*\/>/gi, '');
                paragraphContent = paragraphContent.replace(/<text[^>]*>/gi, '').replace(/<\/text>/gi, '');

                // タグ間の余分な空白・改行を正規化
                paragraphContent = paragraphContent.replace(/>\s+</g, '><');

                // インライン<font>タグをHTMLに変換
                paragraphContent = this.convertDecorationTagsToHTML(paragraphContent);

                console.log(`[EDITOR] 段落${paragraphCount} (閉じタグなし) HTML変換後(最初の100文字):`, JSON.stringify(paragraphContent.substring(0, 100)));

                // 空の段落（XMLソースの整形による改行のみの段落）はスキップ
                if (paragraphContent.trim()) {
                    htmlContent += `<p style="${style}">${paragraphContent}</p>`;
                }
            }

            if (htmlContent) {
                this.editor.innerHTML = htmlContent;
                console.log('[EDITOR] TAD XMLコンテンツを設定しました, 段落数:', paragraphCount);

                // 仮身要素にイベントハンドラを追加
                this.setupVirtualObjectEventHandlers();
            } else {
                console.warn('[EDITOR] 段落要素が見つかりませんでした');
                this.editor.innerHTML = '<p>段落が見つかりませんでした</p>';
            }

            // ビューモードを清書モードに設定
            this.viewMode = 'formatted';
        } catch (error) {
            console.error('[EDITOR] XML描画エラー:', error);
            this.editor.innerHTML = '<p>XMLの描画に失敗しました</p><pre>' + this.escapeHtml(error.message) + '</pre>';
        }
    }

    /**
     * 仮身要素にイベントハンドラを設定
     */
    setupVirtualObjectEventHandlers() {
        const virtualObjects = this.editor.querySelectorAll('.virtual-object');
        console.log('[EDITOR] 仮身要素の数:', virtualObjects.length);

        virtualObjects.forEach(vo => {
            // シングルクリックイベント: 選択/非選択を切り替え
            vo.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // 他の仮身の選択を解除
                this.editor.querySelectorAll('.virtual-object.selected').forEach(other => {
                    if (other !== vo) {
                        other.classList.remove('selected');
                    }
                });

                // この仮身の選択状態をトグル
                vo.classList.toggle('selected');

                const linkName = vo.dataset.linkName || vo.textContent;
                if (vo.classList.contains('selected')) {
                    console.log('[EDITOR] 仮身選択:', linkName);
                    this.setStatus(`仮身選択: ${linkName}`);
                } else {
                    console.log('[EDITOR] 仮身選択解除:', linkName);
                    this.setStatus('');
                }
            });

            // ダブルクリックイベント: defaultOpenアプリで開く
            vo.addEventListener('dblclick', async (e) => {
                e.preventDefault();
                e.stopPropagation();

                const linkId = vo.dataset.linkId;
                const linkName = vo.dataset.linkName;
                console.log('[EDITOR] 仮身ダブルクリック:', linkName, linkId);

                // 実身IDを抽出（拡張子とレコード番号を削除）
                let realId = linkId.replace(/\.(xtad|json)$/, '');
                realId = realId.replace(/_\d+$/, '');

                // realId.jsonを読み込んでdefaultOpenを取得
                try {
                    const appListData = await this.getAppListData(realId);
                    if (!appListData) {
                        this.setStatus('appListの取得に失敗しました');
                        return;
                    }

                    const defaultOpen = this.getDefaultOpenFromAppList(appListData);
                    if (defaultOpen) {
                        console.log('[EDITOR] defaultOpenアプリで起動:', defaultOpen);

                        // 親ウィンドウに実身を開くよう要求
                        const virtualObj = this.buildVirtualObjFromDataset(vo.dataset);

                        window.parent.postMessage({
                            type: 'open-virtual-object-real',
                            virtualObj: virtualObj,
                            pluginId: defaultOpen
                        }, '*');
                    } else {
                        this.setStatus('defaultOpenが設定されていません');
                    }
                } catch (error) {
                    console.error('[EDITOR] defaultOpen取得エラー:', error);
                    this.setStatus('defaultOpenの取得に失敗しました');
                }
            });

            // 右クリックイベント: 仮身の情報を保存（メニューは通常の右クリックメニューで表示）
            vo.addEventListener('contextmenu', () => {
                // 右クリックされた仮身の情報を保存
                const linkId = vo.dataset.linkId;
                const linkName = vo.dataset.linkName;
                console.log('[EDITOR] 仮身右クリック:', linkName, linkId);

                // 仮身を選択状態にする
                this.editor.querySelectorAll('.virtual-object.selected').forEach(other => {
                    other.classList.remove('selected');
                });
                vo.classList.add('selected');

                // 実身IDを抽出して保存
                let realId = linkId.replace(/\.(xtad|json)$/, '');
                realId = realId.replace(/_\d+$/, '');
                console.log('[EDITOR] 抽出されたrealId:', realId, 'from linkId:', linkId);

                // 右クリックされた仮身の情報を保存（メニュー生成時に使用）
                this.contextMenuVirtualObject = {
                    element: vo,
                    realId: realId,
                    virtualObj: this.buildVirtualObjFromDataset(vo.dataset)
                };
                console.log('[EDITOR] contextMenuVirtualObject設定完了:', this.contextMenuVirtualObject);

                // イベントを伝播させて通常の右クリックメニューを表示
            });
        });
    }

    /**
     * 実身のJSON metadataからappListを取得
     */
    async getAppListData(realId) {
        try {
            console.log('[EDITOR] getAppListData開始 realId:', realId);
            const jsonFileName = `${realId}.json`;
            console.log('[EDITOR] JSONファイル名:', jsonFileName);

            // 親ウィンドウ経由でファイルを読み込む（仮身一覧プラグインと同じ方法）
            return new Promise((resolve) => {
                const messageId = `load-json-${Date.now()}-${Math.random()}`;
                let timeoutId = null;

                const messageHandler = async (event) => {
                    // messageIdまたはrequestIdで一致確認（両方に対応）
                    const matchesId = event.data.messageId === messageId || event.data.requestId === messageId;

                    if (event.data && event.data.type === 'load-data-file-response' && matchesId) {
                        // タイムアウトをクリア
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                            timeoutId = null;
                        }
                        window.removeEventListener('message', messageHandler);

                        if (event.data.success) {
                            try {
                                console.log('[EDITOR] JSONファイル読み込み成功（親ウィンドウ経由）:', jsonFileName);

                                // dataフィールド（Fileオブジェクト）またはcontentフィールド（テキスト）に対応
                                let jsonText;
                                if (event.data.data && event.data.data instanceof File) {
                                    console.log('[EDITOR] Fileオブジェクトをテキストとして読み込み');
                                    jsonText = await event.data.data.text();
                                } else if (event.data.content) {
                                    jsonText = event.data.content;
                                } else {
                                    console.error('[EDITOR] レスポンスにdataまたはcontentフィールドがありません');
                                    resolve(null);
                                    return;
                                }

                                const jsonData = JSON.parse(jsonText);
                                console.log('[EDITOR] JSONパース成功 keys:', Object.keys(jsonData));

                                // applistセクションを返す（小文字）
                                if (jsonData.applist) {
                                    console.log('[EDITOR] applist found:', Object.keys(jsonData.applist));
                                    resolve(jsonData.applist);
                                } else {
                                    console.warn('[EDITOR] applistが設定されていません jsonData:', jsonData);
                                    resolve(null);
                                }
                            } catch (error) {
                                console.error('[EDITOR] JSONパースエラー:', error);
                                resolve(null);
                            }
                        } else {
                            console.error('[EDITOR] JSONファイル読み込み失敗:', event.data.error);
                            resolve(null);
                        }
                    }
                };

                window.addEventListener('message', messageHandler);

                // 親ウィンドウにファイル読み込みを要求
                window.parent.postMessage({
                    type: 'load-data-file-request',
                    fileName: jsonFileName,
                    messageId: messageId,
                    requestId: messageId  // 親ウィンドウはrequestIdを使用
                }, '*');

                console.log('[EDITOR] 親ウィンドウにファイル読み込み要求送信:', jsonFileName);

                // タイムアウト処理（10秒）
                timeoutId = setTimeout(() => {
                    window.removeEventListener('message', messageHandler);
                    console.error('[EDITOR] JSONファイル読み込みタイムアウト:', jsonFileName);
                    resolve(null);
                }, 10000);
            });
        } catch (error) {
            console.error('[EDITOR] appList取得エラー:', error);
            return null;
        }
    }

    /**
     * appListからdefaultOpenのプラグインIDを取得
     */
    getDefaultOpenFromAppList(appListData) {
        for (const [pluginId, appInfo] of Object.entries(appListData)) {
            if (appInfo.defaultOpen === true) {
                return pluginId;
            }
        }
        return null;
    }

    /**
     * datasetからvirtualObjを構築
     */
    buildVirtualObjFromDataset(dataset) {
        const virtualObj = {};
        for (const key in dataset) {
            if (key.startsWith('link')) {
                const attrName = key.replace(/^link/, '').toLowerCase();
                virtualObj['link_' + attrName] = dataset[key];
            }
        }
        return virtualObj;
    }

    /**
     * 仮身の右クリックメニューを表示
     */
    showVirtualObjectContextMenu(e, vo, appListData) {
        console.log('[EDITOR] 仮身の右クリックメニュー表示', appListData);

        // 親ウィンドウにメニュー表示を要求
        const rect = window.frameElement.getBoundingClientRect();

        // 実行メニュー項目を作成
        const executeSubmenu = [];
        for (const [pluginId, appInfo] of Object.entries(appListData)) {
            executeSubmenu.push({
                label: appInfo.name || pluginId,
                action: `execute-with-${pluginId}`,
                pluginId: pluginId
            });
        }

        // メニュー定義
        const contextMenuDef = [
            {
                label: '実行',
                submenu: executeSubmenu
            }
        ];

        // 仮身情報も一緒に送信
        const virtualObj = this.buildVirtualObjFromDataset(vo.dataset);

        window.parent.postMessage({
            type: 'show-virtual-object-context-menu',
            x: rect.left + e.clientX,
            y: rect.top + e.clientY,
            menuDefinition: contextMenuDef,
            virtualObj: virtualObj
        }, '*');
    }

    /**
     * HTMLエスケープ
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * HTMLデコード
     */
    decodeHtml(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        return div.textContent;
    }

    /**
     * ファイルを保存
     */
    async saveFile() {
        try {
            this.setStatus('保存中...');

            // エディタのHTMLを取得
            const html = this.editor.innerHTML;

            // Electron環境の場合
            if (typeof window.electronAPI !== 'undefined') {
                const filePath = await window.electronAPI.saveFileDialog(this.currentFile?.fileName || 'document.xml');
                if (filePath) {
                    const data = new TextEncoder().encode(html);
                    const result = await window.electronAPI.saveFile(filePath, Array.from(data));
                    if (result.success) {
                        this.setStatus('保存しました');
                    } else {
                        this.setStatus('保存に失敗しました');
                    }
                }
            } else {
                // ブラウザ環境: ダウンロード
                this.downloadAsFile(html, this.currentFile?.fileName || 'document.html');
                this.setStatus('ダウンロードしました');
            }
        } catch (error) {
            console.error('保存エラー:', error);
            this.setStatus('保存に失敗しました');
        }
    }

    /**
     * エディタの内容をTAD XML形式に変換（TAD XMLタグをそのまま抽出）
     */
    convertEditorToXML() {
        console.log('[EDITOR] convertEditorToXML開始');
        console.log('[EDITOR] エディタHTML:', this.editor.innerHTML.substring(0, 500));

        const xmlParts = ['<tad version="1.0" encoding="UTF-8">\r\n'];
        xmlParts.push('<document>\r\n');

        // エディタの各段落（<p>タグ）を処理
        const paragraphs = this.editor.querySelectorAll('p');
        console.log('[EDITOR] 段落数:', paragraphs.length);

        if (paragraphs.length === 0) {
            console.warn('[EDITOR] 段落が見つかりません。エディタの全内容を1段落として処理します');
            // 段落がない場合、エディタ全体を1つの段落として扱う
            xmlParts.push('<p>\r\n');
            this.extractTADXMLFromElement(this.editor, xmlParts);
            xmlParts.push('\r\n</p>\r\n');
        } else {
            paragraphs.forEach((p, index) => {
                console.log(`[EDITOR] 段落${index} HTML:`, p.innerHTML.substring(0, 200));
                xmlParts.push('<p>\r\n');

                // 段落のスタイルを解析してタグに変換
                const fontSize = this.extractFontSize(p);
                const fontFamily = this.extractFontFamily(p);
                const color = this.extractColor(p);
                const textAlign = this.extractTextAlign(p);

                console.log(`[EDITOR] 段落${index} スタイル:`, { fontSize, fontFamily, color, textAlign });

                // text-align情報を自己閉じタグとして追加
                if (textAlign && textAlign !== 'left') {
                    xmlParts.push(`<text align="${textAlign}"/>`);
                }

                // フォント情報を自己閉じタグとして追加
                if (fontFamily) {
                    xmlParts.push(`<font face="${fontFamily}"/>`);
                }
                if (fontSize) {
                    xmlParts.push(`<font size="${fontSize}"/>`);
                }
                if (color) {
                    xmlParts.push(`<font color="${color}"/>`);
                }

                // 段落の内容を取得（TAD XMLタグをそのまま保持）
                this.extractTADXMLFromElement(p, xmlParts);

                xmlParts.push('\r\n</p>\r\n');
            });
        }

        xmlParts.push('</document>\r\n');
        xmlParts.push('</tad>\r\n');

        const xml = xmlParts.join('');
        console.log('[EDITOR] convertEditorToXML完了, XML長さ:', xml.length);
        console.log('[EDITOR] XMLプレビュー:', xml.substring(0, 500));

        return xml;
    }

    /**
     * 要素からTAD XMLタグを抽出（タグをそのまま保持）
     */
    extractTADXMLFromElement(element, xmlParts, fontState = { size: '9.6', color: '#000000', face: '' }) {
        // xmlPartsが配列でない場合（古い呼び出し方）は、配列を作成して戻り値を返す
        const isOldStyle = !Array.isArray(xmlParts);
        if (isOldStyle) {
            fontState = xmlParts || { size: '9.6', color: '#000000', face: '' };
            xmlParts = [];
        }

        const nodes = element.childNodes;

        nodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) {
                // テキストノードはXMLエスケープして追加
                xmlParts.push(this.escapeXml(node.textContent));
            } else if (node.nodeName === 'BR') {
                // 改行タグ
                xml += '<br/>';
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const nodeName = node.nodeName.toLowerCase();

                // TAD XMLタグはそのまま出力
                if (['underline', 'overline', 'strikethrough', 'bagchar', 'box', 'invert', 'mesh', 'noprint', 'ruby'].includes(nodeName)) {
                    // 開始タグ
                    xml += `<${nodeName}`;

                    // 属性を追加
                    if (nodeName === 'ruby') {
                        const position = node.getAttribute('position') || '0';
                        const text = node.getAttribute('text') || '';
                        xml += ` position="${position}" text="${this.escapeXml(text)}"`;
                    }

                    xml += '>';

                    // 子要素を再帰的に処理（現在のフォント状態を引き継ぐ）
                    xml += this.extractTADXMLFromElement(node, fontState);

                    // 終了タグ
                    xml += `</${nodeName}>`;
                }
                // document.execCommandで追加されるHTML要素を処理
                else if (nodeName === 'font') {
                    // <font>タグのスタイルを抽出
                    const color = this.rgbToHex(node.color || node.style.color);
                    const sizeAttr = node.size || this.extractFontSize(node);
                    const face = node.face || this.extractFontFamily(node);

                    // 現在の状態を保存
                    const prevState = { ...fontState };
                    
                    // 新しい状態を作成
                    const newState = { ...fontState };
                    
                    // フォント情報をXMLの自己閉じタグとして出力（開始）
                    if (color) {
                        xml += `<font color="${color}"/>`;
                        newState.color = color;
                    }
                    if (sizeAttr) {
                        xml += `<font size="${sizeAttr}"/>`;
                        newState.size = sizeAttr;
                    }
                    if (face) {
                        xml += `<font face="${face}"/>`;
                        newState.face = face;
                    }

                    // 子要素を再帰的に処理（新しいフォント状態を渡す）
                    xml += this.extractTADXMLFromElement(node, newState);

                    // フォント情報を元に戻す（終了）- 逆順で前の状態に戻す
                    if (face) {
                        xml += `<font face="${prevState.face}"/>`;
                    }
                    if (sizeAttr) {
                        xml += `<font size="${prevState.size}"/>`;
                    }
                    if (color) {
                        xml += `<font color="${prevState.color}"/>`;
                    }
                }
                else if (nodeName === 'b' || nodeName === 'strong') {
                    xml += '<bold>';
                    xml += this.extractTADXMLFromElement(node, fontState);
                    xml += '</bold>';
                }
                else if (nodeName === 'i' || nodeName === 'em') {
                    xml += '<italic>';
                    xml += this.extractTADXMLFromElement(node, fontState);
                    xml += '</italic>';
                }
                else if (nodeName === 'u') {
                    xml += '<underline>';
                    xml += this.extractTADXMLFromElement(node, fontState);
                    xml += '</underline>';
                }
                else if (nodeName === 'sup') {
                    xml += '<superscript>';
                    xml += this.extractTADXMLFromElement(node, fontState);
                    xml += '</superscript>';
                }
                else if (nodeName === 'sub') {
                    xml += '<subscript>';
                    xml += this.extractTADXMLFromElement(node, fontState);
                    xml += '</subscript>';
                }
                else if (nodeName === 'span') {
                    // 仮身（virtual-object）を<link>タグに変換
                    if (node.classList && node.classList.contains('virtual-object')) {
                        // すべてのdata-link-*属性を復元（innercontentを除く）
                        let attrs = '';
                        let innerContent = '';
                        for (const key in node.dataset) {
                            if (key.startsWith('link')) {
                                const attrName = key.replace(/^link/, '').toLowerCase();
                                const attrValue = node.dataset[key];

                                // innercontentは属性ではなくタグ内テキストとして扱う
                                if (attrName === 'innercontent') {
                                    innerContent = attrValue;
                                } else {
                                    attrs += ` ${attrName}="${this.escapeXml(attrValue)}"`;
                                }
                            }
                        }
                        xml += `<link${attrs}>${this.escapeXml(innerContent)}</link>`;
                    } else {
                        // spanタグのスタイルを解析
                        const style = node.style;

                        // 現在の状態を保存
                        const prevState = { ...fontState };

                        // 新しい状態を作成
                        const newState = { ...fontState };

                        // スタイル開始
                        if (style.color) {
                            const hexColor = this.rgbToHex(style.color);
                            xml += `<font color="${hexColor}"/>`;
                            newState.color = hexColor;
                        }
                        if (style.fontSize) {
                            const size = style.fontSize.replace('pt', '');
                            xml += `<font size="${size}"/>`;
                            newState.size = size;
                        }
                        if (style.fontFamily) {
                            xml += `<font face="${style.fontFamily}"/>`;
                            newState.face = style.fontFamily;
                        }

                        // 子要素を再帰的に処理（新しいフォント状態を渡す）
                        xml += this.extractTADXMLFromElement(node, newState);

                        // スタイル終了 - 逆順で前の状態に戻す
                        if (style.fontFamily) {
                            xml += `<font face="${prevState.face}"/>`;
                        }
                        if (style.fontSize) {
                            xml += `<font size="${prevState.size}"/>`;
                        }
                        if (style.color) {
                            xml += `<font color="${prevState.color}"/>`;
                        }
                    }
                }
                else {
                    // その他のHTML要素は内容のみ抽出（現在のフォント状態を引き継ぐ）
                    xml += this.extractTADXMLFromElement(node, fontState);
                }
            }
        });

        return xml;
    }

    /**
     * 段落からフォントサイズを抽出
     */
    extractFontSize(element) {
        const style = element.style.fontSize;
        if (style) {
            return style.replace('pt', '');
        }
        return null;
    }

    /**
     * 段落からフォントファミリーを抽出
     */
    extractFontFamily(element) {
        const style = element.style.fontFamily;
        if (style) {
            return style.replace(/['"]/g, '');
        }
        return null;
    }

    /**
     * 段落から色を抽出
     */
    extractColor(element) {
        const style = element.style.color;
        if (style) {
            // RGB形式をそのまま返す
            return style;
        }
        return null;
    }

    /**
     * 段落からtext-alignを抽出
     */
    extractTextAlign(element) {
        const style = element.style.textAlign;
        if (style) {
            return style;
        }
        return 'left';
    }

    /**
     * HTML要素からテキストを抽出（<br>は改行として保持、文字修飾をTADタグに変換）
     */
    convertHTMLToText(element) {
        let text = '';
        const nodes = element.childNodes;

        nodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) {
                text += this.escapeXml(node.textContent);
            } else if (node.nodeName === 'BR') {
                text += '<br/>';
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const nodeName = node.nodeName.toUpperCase();
                const innerText = this.convertHTMLToText(node);

                // HTML要素をTAD XMLタグに変換
                if (nodeName === 'U') {
                    text += `<underline>${innerText}</underline>`;
                } else if (nodeName === 'S') {
                    text += `<strikethrough>${innerText}</strikethrough>`;
                } else if (nodeName === 'RUBY') {
                    // rubyタグの処理
                    const rt = node.querySelector('rt');
                    const rtc = node.querySelector('rtc');
                    let baseText = '';
                    let rubyText = '';
                    let position = '0';

                    // ベーステキストを取得（rtとrtc以外のテキストノード）
                    node.childNodes.forEach(child => {
                        if (child.nodeType === Node.TEXT_NODE) {
                            baseText += child.textContent;
                        } else if (child.nodeName !== 'RT' && child.nodeName !== 'RTC') {
                            baseText += child.textContent;
                        }
                    });

                    if (rtc) {
                        // 下側ルビ
                        rubyText = rtc.textContent;
                        position = '1';
                    } else if (rt) {
                        // 上側ルビ
                        rubyText = rt.textContent;
                        position = '0';
                    }

                    text += `<ruby position="${position}" text="${this.escapeXml(rubyText)}">${this.escapeXml(baseText)}</ruby>`;
                } else if (nodeName === 'SPAN') {
                    const style = node.getAttribute('style') || '';
                    const dataNoprint = node.getAttribute('data-noprint');

                    if (dataNoprint) {
                        text += `<noprint>${innerText}</noprint>`;
                    } else if (style.includes('text-decoration: overline')) {
                        text += `<overline>${innerText}</overline>`;
                    } else if (style.includes('-webkit-text-stroke')) {
                        text += `<bagchar>${innerText}</bagchar>`;
                    } else if (style.includes('border: 1px solid')) {
                        text += `<box>${innerText}</box>`;
                    } else if (style.includes('background-color: currentColor')) {
                        text += `<invert>${innerText}</invert>`;
                    } else if (style.includes('repeating-linear-gradient')) {
                        text += `<mesh>${innerText}</mesh>`;
                    } else {
                        text += innerText;
                    }
                } else {
                    // その他の要素はそのまま内容を追加
                    text += innerText;
                }
            }
        });

        return text;
    }

    /**
     * XMLエスケープ
     */
    escapeXml(text) {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    }

    /**
     * RGB/RGBA形式の色を#rrggbb形式に変換
     * @param {string} color - rgb(r, g, b) または rgba(r, g, b, a) または #rrggbb 形式の色
     * @returns {string} #rrggbb形式の色
     */
    rgbToHex(color) {
        if (!color) return '';
        
        // 既に#rrggbb形式の場合はそのまま返す
        if (color.startsWith('#')) {
            return color;
        }

        // rgb(r, g, b) または rgba(r, g, b, a) 形式をパース
        const rgbMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
        if (rgbMatch) {
            const r = parseInt(rgbMatch[1], 10);
            const g = parseInt(rgbMatch[2], 10);
            const b = parseInt(rgbMatch[3], 10);
            
            // 16進数に変換して#rrggbb形式で返す
            return '#' + [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
        }

        // パースできない場合はそのまま返す
        return color;
    }

    /**
     * XMLとしてエクスポート
     * エディタの内容をTAD XML形式に変換して保存
     */
    async exportToXML() {
        try {
            this.setStatus('エクスポート中...');

            // エディタの内容をTAD XML形式に変換
            const xmlContent = this.convertEditorToXML();

            // 変換後のXMLをtadDataに保存（原稿モード表示用）
            this.tadData = xmlContent;

            console.log('[EDITOR] XMLエクスポート, 長さ:', xmlContent.length);

            // Electron環境の場合
            if (typeof window.electronAPI !== 'undefined') {
                const filePath = await window.electronAPI.saveFileDialog(
                    this.currentFile?.fileName?.replace(/\.[^.]+$/, '.xml') || 'document.xml'
                );
                if (filePath) {
                    const data = new TextEncoder().encode(xmlContent);
                    const result = await window.electronAPI.saveFile(filePath, Array.from(data));
                    if (result.success) {
                        this.setStatus('XMLエクスポートしました');
                    } else {
                        this.setStatus('エクスポートに失敗しました');
                    }
                }
            } else {
                // ブラウザ環境: ダウンロード
                const fileName = this.currentFile?.fileName?.replace(/\.[^.]+$/, '.xml') || 'document.xml';
                this.downloadAsFile(xmlContent, fileName);
                this.setStatus('XMLダウンロードしました');
            }
        } catch (error) {
            console.error('[EDITOR] エクスポートエラー:', error);
            this.setStatus('エクスポートに失敗しました');
        }
    }

    /**
     * 親ウインドウにXMLデータの変更を通知（自動保存用）
     */
    notifyXmlDataChanged() {
        if (window.parent && window.parent !== window) {
            // エディタの内容をTAD XML形式に変換
            const xmlContent = this.convertEditorToXML();

            // tadDataを更新
            this.tadData = xmlContent;

            window.parent.postMessage({
                type: 'xml-data-changed',
                fileId: this.fileId,
                xmlData: xmlContent
            }, '*');
            console.log('[EDITOR] xmlTAD変更を通知, fileId:', this.fileId);
        }
    }

    /**
     * ファイルとしてダウンロード
     */
    downloadAsFile(content, filename) {
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }

    /**
     * ステータスを設定
     * btron-desktop.htmlのステータスバーにメッセージを送信
     */
    setStatus(message) {
        console.log(`[基本文章編集] ${message}`);

        // 親ウィンドウにステータスメッセージを送信
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'status-message',
                message: message
            }, '*');
        }
    }

    /**
     * 入力ダイアログを表示（プロンプトの置き換え）
     * @param {string} message - 表示するメッセージ
     * @param {string} defaultValue - デフォルト値
     * @param {number} inputWidth - 入力欄の幅（文字数）
     * @returns {Promise<string|null>} - 入力値またはnull（キャンセル時）
     */
    showInputDialog(message, defaultValue = '', inputWidth = 30) {
        return new Promise((resolve) => {
            const messageId = ++this.dialogMessageId;

            // コールバックを登録
            this.dialogCallbacks[messageId] = (result) => {
                // 「取り消し」ボタンの場合はnullを返す
                if (result.button === 'cancel') {
                    resolve(null);
                } else {
                    resolve(result.value);
                }
            };

            // 親ウィンドウにダイアログ表示を要求
            window.parent.postMessage({
                type: 'show-input-dialog',
                messageId: messageId,
                message: message,
                defaultValue: defaultValue,
                inputWidth: inputWidth,
                buttons: [
                    { label: '取り消し', value: 'cancel' },
                    { label: '設　定', value: 'ok' }
                ],
                defaultButton: 1
            }, '*');
        });
    }

    /**
     * メッセージダイアログを表示
     * @param {string} message - 表示するメッセージ
     * @param {Array} buttons - ボタン定義配列
     * @param {number} defaultButton - デフォルトボタンのインデックス
     * @returns {Promise<any>} - 選択されたボタンの値
     */
    showMessageDialog(message, buttons, defaultButton = 0) {
        return new Promise((resolve) => {
            const messageId = ++this.dialogMessageId;

            // コールバックを登録
            this.dialogCallbacks[messageId] = (result) => {
                resolve(result);
            };

            // 親ウィンドウにダイアログ表示を要求
            window.parent.postMessage({
                type: 'show-message-dialog',
                messageId: messageId,
                message: message,
                buttons: buttons,
                defaultButton: defaultButton
            }, '*');
        });
    }

    /**
     * ウィンドウアクティベーションのセットアップ
     */
    setupWindowActivation() {
        // ウィンドウ内のクリックでウィンドウを最前面に
        document.addEventListener('mousedown', (e) => {
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'activate-window'
                }, '*');
            }
        });
    }

    /**
     * 右クリックメニューのセットアップ
     * ※btron-desktop.htmlのメニューシステムを使用するため、独自メニューは無効化
     */
    setupContextMenu() {
        // iframe内の右クリックを無効化し、親ウィンドウに通知
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();

            // 親ウィンドウに右クリック位置を通知
            if (window.parent && window.parent !== window) {
                // iframeの位置を取得
                const rect = window.frameElement.getBoundingClientRect();

                window.parent.postMessage({
                    type: 'context-menu-request',
                    x: rect.left + e.clientX,
                    y: rect.top + e.clientY
                }, '*');
            }
        });
    }

    /**
     * メニュー定義
     */
    async getMenuDefinition() {
        const menuDef = [
            { label: '保存', action: 'save' },
            {
                label: '表示',
                submenu: [
                    { label: '原稿（xml直接表示）モード', action: 'view-xml' },
                    { label: '清書モード', action: 'view-formatted' },
                    { separator: true },
                    { label: '全画面表示オンオフ', action: 'toggle-fullscreen' },
                    { label: '再表示', action: 'refresh' },
                    { label: '背景色変更', action: 'change-bg-color' },
                    { separator: true },
                    { label: 'ウインドウ幅で折り返し', action: 'toggle-wrap' }
                ]
            },
            {
                label: '編集',
                submenu: [
                    { label: '取消', action: 'undo' },
                    { label: 'クリップボードへコピー', action: 'copy', shortcut: 'Ctrl+C' },
                    { label: 'クリップボードからコピー', action: 'paste', shortcut: 'Ctrl+V' },
                    { label: 'クリップボードへ移動', action: 'cut', shortcut: 'Ctrl+X' },
                    { label: 'クリップボードから移動', action: 'redo', shortcut: 'Ctrl+Z' },
                    { separator: true },
                    { label: 'すべて選択', action: 'select-all' },
                    { separator: true },
                    { label: '検索/置換', action: 'find-replace' }
                ]
            },
            {
                label: '書体',
                submenu: [
                    { label: '書体一覧', action: 'font-list' },
                    { separator: true },
                    { label: 'ゴシック', action: 'font-gothic' },
                    { label: '明朝', action: 'font-mincho' },
                    { label: 'メイリオ', action: 'font-meiryo' }
                ]
            },
            {
                label: '文字修飾',
                submenu: [
                    { label: '標準', action: 'style-normal' },
                    { label: '太字', action: 'style-bold', shortcut: 'Ctrl+B' },
                    { label: '斜体', action: 'style-italic' },
                    { label: '袋文字', action: 'style-bagchar' },
                    { label: '枠囲み', action: 'style-box' },
                    { label: '影付き', action: 'style-shadow' },
                    { separator: true },
                    { label: '下線', action: 'style-underline' },
                    { label: '上線', action: 'style-overline' },
                    { label: '取り消し線', action: 'style-strikethrough' },
                    { label: '網掛', action: 'style-hatched' },
                    { label: '反転', action: 'style-inverse' },
                    { label: '無印字', action: 'style-noprint' },
                    { separator: true },
                    { label: '上付き', action: 'style-superscript' },
                    { label: '下付き', action: 'style-subscript' },
                    { label: '解除', action: 'style-clear' }
                ]
            },
            {
                label: '文字サイズ',
                submenu: [
                    { label: '5（1/2倍）', action: 'size-5' },
                    { label: '7（3/4倍）', action: 'size-7' },
                    { label: '8', action: 'size-8' },
                    { label: '9.6（標準）', action: 'size-9.6' },
                    { label: '11', action: 'size-11' },
                    { label: '12', action: 'size-12' },
                    { label: '13', action: 'size-13' },
                    { label: '14', action: 'size-14' },
                    { label: '16', action: 'size-16' },
                    { label: '18', action: 'size-18' },
                    { label: '19.2（2倍）', action: 'size-19.2' },
                    { label: '29（3倍）', action: 'size-29' },
                    { label: '38（4倍）', action: 'size-38' },
                    { label: '58（6倍）', action: 'size-58' },
                    { label: '77（8倍）', action: 'size-77' },
                    { separator: true },
                    { label: '数値指定', action: 'size-custom' },
                    { separator: true },
                    { label: '全角', action: 'size-fullwidth' },
                    { label: '半角', action: 'size-halfwidth' }
                ]
            },
            {
                label: '文字色',
                submenu: [
                    { label: '黒色', action: 'color-black' },
                    { label: '青色', action: 'color-blue' },
                    { label: '赤色（238,0,0）', action: 'color-red' },
                    { label: 'ピンク色', action: 'color-pink' },
                    { label: '橙色', action: 'color-orange' },
                    { label: '緑色', action: 'color-green' },
                    { label: '黄緑色', action: 'color-lime' },
                    { label: '水色', action: 'color-cyan' },
                    { label: '黄色', action: 'color-yellow' },
                    { label: '白色', action: 'color-white' },
                    { separator: true },
                    { label: '文字色指定（RGB（FFFFFF））', action: 'color-custom' }
                ]
            },
            {
                label: '書式',
                submenu: [
                    { label: '字下げ', action: 'format-indent' },
                    {
                        label: '行揃え',
                        submenu: [
                            { label: '行頭揃え', action: 'align-left' },
                            { label: '中央揃え', action: 'align-center' },
                            { label: '行末揃え', action: 'align-right' }
                        ]
                    },
                    { separator: true },
                    {
                        label: 'ルビ',
                        submenu: [
                            { label: 'ルビ（上）', action: 'ruby-top' },
                            { label: 'ルビ（下）', action: 'ruby-bottom' }
                        ]
                    },
                    { separator: true },
                    { label: '改ページ', action: 'format-pagebreak' }
                ]
            }
        ];

        // 仮身が選択されている場合は「実行」メニューを追加
        console.log('[EDITOR] getMenuDefinition: contextMenuVirtualObject:', this.contextMenuVirtualObject);
        if (this.contextMenuVirtualObject) {
            try {
                console.log('[EDITOR] getMenuDefinition: 仮身が選択されています realId:', this.contextMenuVirtualObject.realId);
                const applistData = await this.getAppListData(this.contextMenuVirtualObject.realId);
                console.log('[EDITOR] getMenuDefinition: applistData:', applistData);
                if (applistData && Object.keys(applistData).length > 0) {
                    const executeSubmenu = [];
                    for (const [pluginId, appInfo] of Object.entries(applistData)) {
                        console.log('[EDITOR] getMenuDefinition: 実行メニュー項目追加:', pluginId, appInfo);
                        executeSubmenu.push({
                            label: appInfo.name || pluginId,
                            action: `execute-with-${pluginId}`
                        });
                    }

                    menuDef.push({
                        label: '実行',
                        submenu: executeSubmenu
                    });
                    console.log('[EDITOR] getMenuDefinition: 実行メニュー追加完了 項目数:', executeSubmenu.length);
                } else {
                    console.warn('[EDITOR] getMenuDefinition: applistDataが空またはnull');
                }
            } catch (error) {
                console.error('[EDITOR] applist取得エラー:', error);
            }
        } else {
            console.log('[EDITOR] getMenuDefinition: 仮身が選択されていません');
        }

        return menuDef;
    }

    /**
     * コンテキストメニューを表示
     */
    async showContextMenu(x, y) {
        const contextMenu = document.getElementById('context-menu');
        const menuDef = await this.getMenuDefinition();

        contextMenu.innerHTML = this.renderMenu(menuDef);
        contextMenu.style.left = x + 'px';
        contextMenu.style.top = y + 'px';
        contextMenu.classList.add('show');

        // メニュー項目のクリックイベント
        contextMenu.querySelectorAll('.context-menu-item[data-action]').forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const action = item.dataset.action;
                this.executeMenuAction(action);
                this.hideContextMenu();
            });
        });
    }

    /**
     * メニューをHTML化
     */
    renderMenu(menuItems) {
        let html = '';
        menuItems.forEach(item => {
            if (item.separator) {
                html += '<div class="context-menu-separator"></div>';
            } else if (item.submenu) {
                html += `<div class="context-menu-item">
                    <span>${item.label}</span>
                    <span class="arrow">▶</span>
                    <div class="context-submenu">
                        ${this.renderMenu(item.submenu)}
                    </div>
                </div>`;
            } else {
                const shortcut = item.shortcut ? `<span class="shortcut">${item.shortcut}</span>` : '';
                html += `<div class="context-menu-item" data-action="${item.action}">
                    <span>${item.label}</span>
                    ${shortcut}
                </div>`;
            }
        });
        return html;
    }

    /**
     * コンテキストメニューを非表示
     */
    hideContextMenu() {
        const contextMenu = document.getElementById('context-menu');
        contextMenu.classList.remove('show');
    }

    /**
     * メニューアクションを実行
     */
    executeMenuAction(action, additionalData) {
        console.log('[EDITOR] メニューアクション:', action, additionalData);

        // 仮身の実行メニューからのアクション
        if (action.startsWith('execute-with-')) {
            const pluginId = action.replace('execute-with-', '');
            console.log('[EDITOR] 仮身を指定アプリで起動:', pluginId);

            // contextMenuVirtualObjectから仮身情報を取得
            if (this.contextMenuVirtualObject && this.contextMenuVirtualObject.virtualObj) {
                window.parent.postMessage({
                    type: 'open-virtual-object-real',
                    virtualObj: this.contextMenuVirtualObject.virtualObj,
                    pluginId: pluginId
                }, '*');
                this.setStatus(`${pluginId}で実身を開きます`);
            }
            return;
        }

        switch (action) {
            // ファイル操作
            case 'save':
                // 自動保存（実身xtadとjsonのセットで保存）
                this.notifyXmlDataChanged();
                this.isModified = false; // 保存後は未編集状態に
                this.setStatus('保存しました');
                break;

            // 表示
            case 'view-xml':
                this.viewXMLMode();
                break;
            case 'view-formatted':
                this.viewFormattedMode();
                break;
            case 'toggle-fullscreen':
                this.toggleFullscreen();
                break;
            case 'refresh':
                this.refresh();
                break;
            case 'change-bg-color':
                this.changeBgColor();
                break;
            case 'toggle-wrap':
                this.toggleWrap();
                break;

            // 編集
            case 'undo':
                document.execCommand('undo');
                this.setStatus('元に戻しました');
                break;
            case 'copy':
                document.execCommand('copy');
                this.setStatus('クリップボードへコピーしました');
                break;
            case 'paste':
                document.execCommand('paste');
                this.setStatus('クリップボードから貼り付けました');
                break;
            case 'cut':
                document.execCommand('cut');
                this.setStatus('クリップボードへ移動しました');
                break;
            case 'redo':
                document.execCommand('redo');
                this.setStatus('やり直しました');
                break;
            case 'select-all':
                document.execCommand('selectAll');
                this.setStatus('すべて選択しました');
                break;
            case 'find-replace':
                this.findReplace();
                break;

            // 書体
            case 'font-list':
                this.showFontList();
                break;
            case 'font-gothic':
                this.applyFont('sans-serif, "Yu Gothic", "游ゴシック", "Meiryo"');
                break;
            case 'font-mincho':
                this.applyFont('serif, "Yu Mincho", "游明朝", "MS Mincho"');
                break;
            case 'font-meiryo':
                this.applyFont('"Meiryo", "メイリオ"');
                break;

            // 文字修飾
            case 'style-normal':
                this.clearFormatting();
                break;
            case 'style-bold':
                document.execCommand('bold');
                this.setStatus('太字を適用しました');
                break;
            case 'style-italic':
                document.execCommand('italic');
                this.setStatus('斜体を適用しました');
                break;
            case 'style-bagchar':
                this.applyBagchar();
                break;
            case 'style-box':
                this.applyBox();
                break;
            case 'style-shadow':
                this.applyTextShadow();
                break;
            case 'style-underline':
                this.applyUnderline();
                break;
            case 'style-overline':
                this.applyOverline();
                break;
            case 'style-strikethrough':
                this.applyStrikethrough();
                break;
            case 'style-hatched':
                this.applyHatched();
                break;
            case 'style-inverse':
                this.applyInverse();
                break;
            case 'style-noprint':
                this.applyNoprint();
                break;
            case 'style-superscript':
                document.execCommand('superscript');
                this.setStatus('上付きを適用しました');
                break;
            case 'style-subscript':
                document.execCommand('subscript');
                this.setStatus('下付きを適用しました');
                break;
            case 'style-clear':
                document.execCommand('removeFormat');
                this.setStatus('書式を解除しました');
                break;

            // 文字サイズ
            case 'size-custom':
                this.customFontSize();
                break;
            case 'size-fullwidth':
                this.applyFullWidth();
                break;
            case 'size-halfwidth':
                this.applyHalfWidth();
                break;

            // 文字色
            case 'color-black':
                document.execCommand('foreColor', false, '#000000');
                this.setStatus('文字色: 黒');
                break;
            case 'color-blue':
                document.execCommand('foreColor', false, '#0000ff');
                this.setStatus('文字色: 青');
                break;
            case 'color-red':
                document.execCommand('foreColor', false, '#ee0000');
                this.setStatus('文字色: 赤');
                break;
            case 'color-pink':
                document.execCommand('foreColor', false, '#ff69b4');
                this.setStatus('文字色: ピンク');
                break;
            case 'color-orange':
                document.execCommand('foreColor', false, '#ff8c00');
                this.setStatus('文字色: 橙');
                break;
            case 'color-green':
                document.execCommand('foreColor', false, '#008000');
                this.setStatus('文字色: 緑');
                break;
            case 'color-lime':
                document.execCommand('foreColor', false, '#7fff00');
                this.setStatus('文字色: 黄緑');
                break;
            case 'color-cyan':
                document.execCommand('foreColor', false, '#00ffff');
                this.setStatus('文字色: 水色');
                break;
            case 'color-yellow':
                document.execCommand('foreColor', false, '#ffff00');
                this.setStatus('文字色: 黄色');
                break;
            case 'color-white':
                document.execCommand('foreColor', false, '#ffffff');
                this.setStatus('文字色: 白');
                break;
            case 'color-custom':
                this.customColor();
                break;

            // 書式
            case 'format-indent':
                document.execCommand('indent');
                this.setStatus('字下げしました');
                break;
            case 'align-left':
                document.execCommand('justifyLeft');
                this.setStatus('行頭揃え');
                break;
            case 'align-center':
                document.execCommand('justifyCenter');
                this.setStatus('中央揃え');
                break;
            case 'align-right':
                document.execCommand('justifyRight');
                this.setStatus('行末揃え');
                break;
            case 'ruby-top':
                this.insertRuby('0');
                break;
            case 'ruby-bottom':
                this.insertRuby('1');
                break;
            case 'format-pagebreak':
                this.insertPageBreak();
                break;

            default:
                if (action.startsWith('size-')) {
                    const size = action.replace('size-', '');
                    document.execCommand('fontSize', false, '7'); // ダミーサイズを設定
                    const fontElements = document.querySelectorAll('font[size="7"]');
                    fontElements.forEach(el => {
                        el.removeAttribute('size');
                        el.style.fontSize = size + 'pt';
                    });
                    this.setStatus(`文字サイズ: ${size}pt`);
                } else {
                    console.log('[EDITOR] 未実装のアクション:', action);
                    this.setStatus(`未実装: ${action}`);
                }
        }
    }

    /**
     * XML直接表示モード
     */
    viewXMLMode() {
        // XMLモードでない場合（清書モードまたは初期状態）、エディタの内容をXMLに変換
        if (this.viewMode !== 'xml') {
            this.tadData = this.convertEditorToXML();
        }

        if (this.tadData) {
            this.editor.innerHTML = '<pre style="white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 12px; padding: 10px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;">' +
                this.escapeHtml(this.tadData) +
                '</pre>';
            this.viewMode = 'xml';
            this.setStatus('原稿（XML直接表示）モード');
        }
    }

    /**
     * 清書モード
     */
    viewFormattedMode() {
        console.log('[EDITOR] viewFormattedMode開始, 現在のモード:', this.viewMode);
        
        // XMLモードの場合、エディタの内容をXMLに変換してtadDataを更新
        if (this.viewMode === 'xml') {
            // XMLモード時はエディタにXMLテキストが表示されているので、それをtadDataに保存
            const preElement = this.editor.querySelector('pre');
            if (preElement) {
                const rawText = preElement.textContent;
                console.log('[EDITOR] preElement.textContent取得, 長さ:', rawText.length);
                console.log('[EDITOR] 最初の200文字:', rawText.substring(0, 200));
                
                this.tadData = rawText;  // textContentは既にデコード済みなのでdecodeHtmlは不要
                
                console.log('[EDITOR] tadData更新完了, 長さ:', this.tadData.length);
                console.log('[EDITOR] tadDataプレビュー:', this.tadData.substring(0, 200));
            } else {
                console.error('[EDITOR] pre要素が見つかりません');
            }
        } else {
            // 清書モードまたは初期状態の場合、エディタの内容をXMLに変換
            console.log('[EDITOR] 清書モードから変換');
            this.tadData = this.convertEditorToXML();
        }

        if (this.tadData) {
            console.log('[EDITOR] renderTADXML呼び出し, tadData長さ:', this.tadData.length);
            this.renderTADXML(this.tadData);
            this.viewMode = 'formatted';
            this.setStatus('清書モード');
        } else {
            console.error('[EDITOR] tadDataが空です');
            this.editor.innerHTML = '<p>XMLデータがありません</p>';
        }
    }

    /**
     * 全画面表示切り替え
     */
    toggleFullscreen() {
        // 親ウィンドウ（btron-desktop.js）にメッセージを送信してウィンドウを最大化/元に戻す
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'toggle-maximize'
            }, '*');

            this.isFullscreen = !this.isFullscreen;
            this.setStatus(this.isFullscreen ? '全画面表示ON' : '全画面表示OFF');
        } else {
            // 親ウィンドウがない場合は従来のフルスクリーンAPIを使用
            const container = document.querySelector('.editor-container');
            if (!this.isFullscreen) {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                }
                this.isFullscreen = true;
                this.setStatus('全画面表示ON');
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                this.isFullscreen = false;
                this.setStatus('全画面表示OFF');
            }
        }
    }

    /**
     * 再表示
     */
    refresh() {
        if (this.viewMode === 'xml') {
            this.viewXMLMode();
        } else {
            this.viewFormattedMode();
        }
        this.setStatus('再表示しました');
    }

    /**
     * 背景色変更
     */
    async changeBgColor() {
        const color = await this.showInputDialog('背景色を入力してください（例: #ffffff, white）', '#ffffff', 20);
        if (color) {
            this.editor.style.backgroundColor = color;
            this.setStatus(`背景色を${color}に変更しました`);
        }
    }

    /**
     * 折り返し切り替え
     */
    toggleWrap() {
        this.wrapMode = !this.wrapMode;
        if (this.wrapMode) {
            this.editor.style.whiteSpace = 'pre-wrap';
            this.editor.style.wordWrap = 'break-word';
            this.setStatus('ウインドウ幅で折り返し: ON');
        } else {
            this.editor.style.whiteSpace = 'pre';
            this.editor.style.wordWrap = 'normal';
            this.setStatus('ウインドウ幅で折り返し: OFF');
        }

        // 折り返しモード変更後に高さを更新
        setTimeout(() => this.updateContentHeight(), 100);
    }

    /**
     * 検索/置換
     */
    async findReplace() {
        const searchText = await this.showInputDialog('検索する文字列を入力してください', '', 30);
        if (searchText) {
            const replaceText = await this.showInputDialog('置換後の文字列を入力してください（キャンセルで検索のみ）', '', 30);
            const content = this.editor.innerHTML;

            if (replaceText !== null) {
                const newContent = content.split(searchText).join(replaceText);
                this.editor.innerHTML = newContent;
                this.setStatus(`"${searchText}" を "${replaceText}" に置換しました`);
            } else {
                if (content.includes(searchText)) {
                    this.setStatus(`"${searchText}" が見つかりました`);
                } else {
                    this.setStatus(`"${searchText}" は見つかりませんでした`);
                }
            }
        }
    }

    /**
     * 書体一覧表示
     */
    showFontList() {
        const fonts = [
            'ゴシック (sans-serif)',
            '明朝 (serif)',
            'メイリオ (Meiryo)',
            'MS ゴシック (MS Gothic)',
            'MS 明朝 (MS Mincho)',
            '游ゴシック (Yu Gothic)',
            '游明朝 (Yu Mincho)'
        ];
        alert('利用可能な書体:\n\n' + fonts.join('\n'));
    }

    /**
     * フォント適用
     */
    applyFont(fontFamily) {
        document.execCommand('fontName', false, fontFamily);
        this.setStatus(`書体を変更しました: ${fontFamily}`);
    }

    /**
     * 書式クリア
     */
    clearFormatting() {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            this.setStatus('テキストを選択してください');
            return;
        }

        const range = selection.getRangeAt(0);
        
        // 選択範囲のテキストを取得
        const selectedText = range.toString();
        
        if (!selectedText) {
            this.setStatus('テキストを選択してください');
            return;
        }

        // 選択範囲を削除して、プレーンテキストとして再挿入
        range.deleteContents();
        const textNode = document.createTextNode(selectedText);
        range.insertNode(textNode);
        
        // カーソル位置をテキストの後ろに移動
        range.setStartAfter(textNode);
        range.setEndAfter(textNode);
        selection.removeAllRanges();
        selection.addRange(range);
        
        this.setStatus('書式を解除しました');
    }

    /**
     * 袋文字
     */
    applyBagchar() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const bagchar = document.createElement('bagchar');
            range.surroundContents(bagchar);
            this.setStatus('袋文字を適用しました');
        }
    }

    /**
     * 枠囲み
     */
    applyBox() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const box = document.createElement('box');
            range.surroundContents(box);
            this.setStatus('枠囲みを適用しました');
        }
    }

    /**
     * 影付き
     */
    applyTextShadow() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const span = document.createElement('span');
            span.style.textShadow = '2px 2px 4px #00000080';
            range.surroundContents(span);
            this.setStatus('影付きを適用しました');
        }
    }

    /**
     * 網掛
     */
    applyHatched() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const mesh = document.createElement('mesh');
            range.surroundContents(mesh);
            this.setStatus('網掛を適用しました');
        }
    }

    /**
     * 反転
     */
    applyInverse() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const invert = document.createElement('invert');
            range.surroundContents(invert);
            this.setStatus('反転を適用しました');
        }
    }

    /**
     * 下線
     */
    applyUnderline() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const underline = document.createElement('underline');
            range.surroundContents(underline);
            this.setStatus('下線を適用しました');
        }
    }

    /**
     * 上線
     */
    applyOverline() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const overline = document.createElement('overline');
            range.surroundContents(overline);
            this.setStatus('上線を適用しました');
        }
    }

    /**
     * 取り消し線
     */
    applyStrikethrough() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const strikethrough = document.createElement('strikethrough');
            range.surroundContents(strikethrough);
            this.setStatus('取り消し線を適用しました');
        }
    }

    /**
     * 無印字
     */
    applyNoprint() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const noprint = document.createElement('noprint');
            range.surroundContents(noprint);
            this.setStatus('無印字を適用しました');
        }
    }

    /**
     * カスタム文字サイズ
     */
    async customFontSize() {
        const size = await this.showInputDialog('文字サイズを入力してください（pt）', '14', 10);
        if (size && !isNaN(size)) {
            document.execCommand('fontSize', false, '7');
            const fontElements = document.querySelectorAll('font[size="7"]');
            fontElements.forEach(el => {
                el.removeAttribute('size');
                el.style.fontSize = size + 'pt';
            });
            this.setStatus(`文字サイズ: ${size}pt`);
        }
    }

    /**
     * 全角変換
     */
    applyFullWidth() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const text = selection.toString();
            const fullwidth = this.toFullWidth(text);
            document.execCommand('insertText', false, fullwidth);
            this.setStatus('全角に変換しました');
        }
    }

    /**
     * 半角変換
     */
    applyHalfWidth() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const text = selection.toString();
            const halfwidth = this.toHalfWidth(text);
            document.execCommand('insertText', false, halfwidth);
            this.setStatus('半角に変換しました');
        }
    }

    /**
     * 全角変換ヘルパー
     */
    toFullWidth(str) {
        return str.replace(/[!-~]/g, (char) => {
            return String.fromCharCode(char.charCodeAt(0) + 0xFEE0);
        });
    }

    /**
     * 半角変換ヘルパー
     */
    toHalfWidth(str) {
        return str.replace(/[！-～]/g, (char) => {
            return String.fromCharCode(char.charCodeAt(0) - 0xFEE0);
        });
    }

    /**
     * カスタム文字色
     */
    async customColor() {
        const color = await this.showInputDialog('文字色を入力してください（例: #ff0000, #000000）', '#000000', 20);
        if (color) {
            document.execCommand('foreColor', false, color);
            this.setStatus(`文字色: ${color}`);
        }
    }

    /**
     * 改ページ挿入
     */
    insertPageBreak() {
        const pageBreak = document.createElement('div');
        pageBreak.style.pageBreakAfter = 'always';
        pageBreak.style.borderBottom = '2px dashed #ccc';
        pageBreak.style.margin = '20px 0';
        pageBreak.style.padding = '10px 0';
        pageBreak.textContent = '--- 改ページ ---';

        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            range.insertNode(pageBreak);
            this.setStatus('改ページを挿入しました');
        }
    }

    /**
     * ルビ挿入・編集・削除
     * @param {string} position - "0"で上側、"1"で下側
     */
    async insertRuby(position) {
        const selection = window.getSelection();
        if (selection.rangeCount === 0 || selection.isCollapsed) {
            this.setStatus('テキストを選択してからルビを挿入してください');
            return;
        }

        const range = selection.getRangeAt(0);

        // 選択範囲内に既存のrubyタグがあるかチェック
        const container = range.commonAncestorContainer;
        let existingRuby = null;

        if (container.nodeType === Node.ELEMENT_NODE && container.nodeName.toLowerCase() === 'ruby') {
            existingRuby = container;
        } else if (container.parentNode && container.parentNode.nodeName.toLowerCase() === 'ruby') {
            existingRuby = container.parentNode;
        }

        // 既存のルビがある場合は現在のtext属性を取得
        const currentRubyText = existingRuby ? existingRuby.getAttribute('text') || '' : '';

        const rubyText = await this.showInputDialog('ルビを入力してください（空欄で削除）:', currentRubyText, 30);

        // キャンセルされた場合は何もしない
        if (rubyText === null) {
            return;
        }

        // 既存のルビタグがある場合
        if (existingRuby) {
            if (rubyText === '') {
                // 空文字列の場合はルビタグを削除
                const textContent = existingRuby.textContent;
                const textNode = document.createTextNode(textContent);
                existingRuby.parentNode.replaceChild(textNode, existingRuby);
                this.setStatus('ルビを削除しました');
            } else {
                // ルビテキストを更新
                existingRuby.setAttribute('text', rubyText);
                existingRuby.setAttribute('position', position);
                
                // 既存の<rt>または<rtc>を削除して再作成
                const oldRt = existingRuby.querySelector('rt, rtc');
                if (oldRt) {
                    oldRt.remove();
                }
                
                // 新しい<rt>または<rtc>を作成
                if (position === '0') {
                    const rt = document.createElement('rt');
                    rt.textContent = rubyText;
                    existingRuby.appendChild(rt);
                } else {
                    const rtc = document.createElement('rtc');
                    rtc.style.rubyPosition = 'under';
                    rtc.textContent = rubyText;
                    existingRuby.appendChild(rtc);
                }
                
                this.setStatus('ルビを更新しました');
            }
        } else {
            // 新規ルビタグを作成
            if (rubyText !== '') {
                const selectedText = range.toString();
                const ruby = document.createElement('ruby');
                ruby.setAttribute('position', position);
                ruby.setAttribute('text', rubyText);
                
                // ベーステキストを追加
                ruby.textContent = selectedText;
                
                // <rt>または<rtc>を作成して追加
                if (position === '0') {
                    // 上側ルビ
                    const rt = document.createElement('rt');
                    rt.textContent = rubyText;
                    ruby.appendChild(rt);
                } else {
                    // 下側ルビ
                    const rtc = document.createElement('rtc');
                    rtc.style.rubyPosition = 'under';
                    rtc.textContent = rubyText;
                    ruby.appendChild(rtc);
                }

                range.deleteContents();
                range.insertNode(ruby);

                this.setStatus(position === '0' ? 'ルビ（上）を挿入しました' : 'ルビ（下）を挿入しました');
            }
            // rubyTextが空文字列の場合は何もしない
        }
    }

    /**
     * ウィンドウ設定（位置・サイズ・最大化状態）を更新
     * @param {Object} windowConfig - { pos: {x, y}, width, height, maximize }
     */
    updateWindowConfig(windowConfig) {
        if (window.parent && window.parent !== window && this.fileId) {
            window.parent.postMessage({
                type: 'update-window-config',
                fileId: this.fileId,
                windowConfig: windowConfig
            }, '*');

            console.log('[EDITOR] ウィンドウ設定を更新:', windowConfig);
        }
    }

    /**
     * ウィンドウクローズ要求を処理
     * 編集中の場合は保存確認ダイアログを表示
     * @param {string} windowId - ウィンドウID
     */
    async handleCloseRequest(windowId) {
        console.log('[EDITOR] クローズ要求受信, isModified:', this.isModified);

        if (this.isModified) {
            // 編集中の場合、保存確認ダイアログを表示
            const result = await this.showSaveConfirmDialog();
            console.log('[EDITOR] 保存確認ダイアログ結果:', result);

            if (result === 'cancel') {
                // 取消: クローズをキャンセル
                this.respondCloseRequest(windowId, false);
            } else if (result === 'no') {
                // 保存しない: そのままクローズ
                this.respondCloseRequest(windowId, true);
            } else if (result === 'yes') {
                // 保存: 保存してからクローズ
                this.notifyXmlDataChanged();
                this.isModified = false;
                this.respondCloseRequest(windowId, true);
            }
        } else {
            // 未編集の場合、そのままクローズ
            this.respondCloseRequest(windowId, true);
        }
    }

    /**
     * クローズ要求に応答
     * @param {string} windowId - ウィンドウID
     * @param {boolean} allowClose - クローズを許可するか
     */
    respondCloseRequest(windowId, allowClose) {
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'window-close-response',
                windowId: windowId,
                allowClose: allowClose
            }, '*');
        }
    }

    /**
     * 保存確認ダイアログを表示
     * @returns {Promise<string>} 'yes', 'no', 'cancel'
     */
    async showSaveConfirmDialog() {
        return new Promise((resolve) => {
            const messageId = `save-confirm-${++this.dialogMessageId}`;

            // コールバックを登録
            this.dialogCallbacks[messageId] = (result) => {
                resolve(result);
            };

            // 親ウィンドウにダイアログ表示を要求
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'show-save-confirm-dialog',
                    messageId: messageId,
                    message: '保存してから閉じますか？',
                    buttons: [
                        { label: '取消', value: 'cancel' },
                        { label: '保存しない', value: 'no' },
                        { label: '保存', value: 'yes' }
                    ]
                }, '*');
            }
        });
    }
}

// エディタを初期化
document.addEventListener('DOMContentLoaded', () => {
    window.editor = new BasicTextEditor();
});
