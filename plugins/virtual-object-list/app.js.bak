/**
 * 仮身一覧ビューアプラグイン
 */
class VirtualObjectListApp {
    constructor() {
        this.fileData = null;
        this.xmlData = null;
        this.tadData = null;
        this.virtualObjects = [];
        this.selectedVirtualObjects = new Set(); // 選択中の仮身（複数選択対応）
        this.clipboard = null; // クリップボード（仮身データ）
        this.isFullscreen = false; // 全画面表示フラグ
        this.dialogCallbacks = {}; // ダイアログコールバック管理
        this.openedRealObjects = new Map(); // 開いている実身のMap（realId -> windowId）
        this.iconCache = new Map(); // アイコンキャッシュ（realId -> Base64データ）

        // ウィンドウIDを生成（ウィンドウ間のドラッグを区別するため）
        this.windowId = `window-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        // ドラッグ状態管理（グローバル）
        this.draggingState = {
            isDragging: false,
            hasMoved: false,
            currentObject: null,
            currentElement: null,
            startX: 0,
            startY: 0,
            initialLeft: 0,
            initialTop: 0,
            dragMode: 'move' // 'move' or 'copy'
        };

        // リサイズ状態管理
        this.isResizing = false;
        this.recreateVirtualObjectTimer = null; // 仮身再作成の遅延タイマー

        // VirtualObjectRenderer
        this.virtualObjectRenderer = null; // 初期化後に設定

        this.init();
    }

    init() {
        // VirtualObjectRendererの初期化
        if (window.VirtualObjectRenderer) {
            this.virtualObjectRenderer = new window.VirtualObjectRenderer();
            console.log('[VirtualObjectList] VirtualObjectRenderer initialized');
        }

        // パフォーマンス最適化関数の初期化
        if (window.throttleRAF && window.throttle) {
            console.log('[VirtualObjectList] Performance optimization initialized');
        }

        console.log('[VirtualObjectList] 初期化開始');

        // 親ウィンドウからのメッセージを受信
        this.setupMessageHandler();

        // ウィンドウアクティベーション
        this.setupWindowActivation();

        // 右クリックメニュー
        this.setupContextMenu();

        // ドラッグ&ドロップ機能
        this.setupDragAndDrop();

        // キーボードショートカット
        this.setupKeyboardShortcuts();

        // グローバルなマウスイベントハンドラー（ドラッグ用）
        this.setupGlobalMouseHandlers();
    }

    /**
     * ドラッグ&ドロップ機能を設定
     */
    setupDragAndDrop() {
        const listElement = document.getElementById('virtualList');
        if (!listElement) return;

        // ドラッグオーバー
        listElement.addEventListener('dragover', (e) => {
            e.preventDefault();

            // effectAllowedに基づいてdropEffectを設定
            // effectAllowedが'move'の場合は'move'、'copy'の場合は'copy'を使用
            const effectAllowed = e.dataTransfer.effectAllowed;
            if (effectAllowed === 'move') {
                e.dataTransfer.dropEffect = 'move';
            } else if (effectAllowed === 'copy') {
                e.dataTransfer.dropEffect = 'copy';
            } else {
                // デフォルトはcopy
                e.dataTransfer.dropEffect = 'copy';
            }

            listElement.style.backgroundColor = '#e8f4f8';

            // ドラッグ先のウィンドウを判定：別ウィンドウからのドラッグの場合のみ、このウィンドウで仮身を表示
            // このウィンドウがドラッグ元でない場合（別ウィンドウからドラッグされている）、仮身を表示する
            if (!this.draggingState.isDragging) {
                // 別のウィンドウからドラッグされている場合
                // ドラッグ元のcurrentElementを表示する必要があるが、別ウィンドウの要素なのでアクセスできない
                // そのため、何もしない（ブラウザのデフォルトのドラッグイメージが表示される）
            }
            // このウィンドウがドラッグ元の場合は、drag イベントで処理される
        });

        // ドラッグリーブ
        listElement.addEventListener('dragleave', (e) => {
            e.preventDefault();
            listElement.style.backgroundColor = '';
        });

        // ドロップ
        listElement.addEventListener('drop', (e) => {
            e.preventDefault();
            listElement.style.backgroundColor = '';

            try {
                const data = e.dataTransfer.getData('text/plain');
                if (data) {
                    // JSON形式かどうかチェック
                    try {
                        const dragData = JSON.parse(data);

                        if (dragData.type === 'base-file-copy' && dragData.source === 'base-file-manager') {
                            // 原紙管理からのコピー - 親ウィンドウに処理を委譲
                            // 親ウィンドウのhandleBaseFileDropが実身名入力ダイアログを表示する
                            console.log('[VirtualObjectList] 原紙箱からのドロップを親ウィンドウに委譲');

                            // 親ウィンドウにメッセージを送信
                            if (window.parent && window.parent !== window) {
                                window.parent.postMessage({
                                    type: 'base-file-drop-request',
                                    dragData: dragData,
                                    clientX: e.clientX,
                                    clientY: e.clientY
                                }, '*');
                            }
                            return; // 処理を親ウィンドウに任せる
                        } else if (dragData.type === 'trash-real-object-restore' && dragData.source === 'trash-real-objects') {
                            // 屑実身操作からの復元 - 親ウィンドウに処理を委譲
                            console.log('[VirtualObjectList] 屑実身操作からのドロップを親ウィンドウに委譲');

                            // 親ウィンドウにメッセージを送信
                            if (window.parent && window.parent !== window) {
                                window.parent.postMessage({
                                    type: 'trash-real-object-drop-request',
                                    dragData: dragData,
                                    clientX: e.clientX,
                                    clientY: e.clientY
                                }, '*');
                            }
                            return; // 処理を親ウィンドウに任せる
                        } else if (dragData.type === 'archive-file-extract' && dragData.source === 'unpack-file') {
                            // 書庫管理からのファイル抽出
                            this.insertArchiveFileAsVirtualObject(dragData, e.clientX, e.clientY);
                            return; // 処理完了
                        } else if (dragData.type === 'virtual-object-drag') {
                            // 仮身のドラッグ（仮身一覧または基本文章編集プラグインから）
                            console.log('[VirtualObjectList] 仮身ドロップ受信:', dragData.virtualObject.link_name, 'ソース:', dragData.source, 'モード:', dragData.mode);

                            // 基本文章編集プラグインからのドロップは常に別ウィンドウとして扱う
                            const isCrossWindow = dragData.source === 'basic-text-editor' || dragData.sourceWindowId !== this.windowId;
                            console.log('[VirtualObjectList] 仮身ドロップ受信: ソース:', dragData.source, 'モード:', dragData.mode, 'ソースウィンドウID:', dragData.sourceWindowId, '現在のウィンドウID:', this.windowId, 'クロスウィンドウ:', isCrossWindow);

                            if (isCrossWindow) {
                                // 別ウィンドウからのドロップ成功をマーク（dragendでfinishDrag()をスキップするため）
                                console.log('[VirtualObjectList] クロスウィンドウドロップ検知、元ウィンドウに通知');

                                // ドロップ先（このウィンドウ）で仮身を挿入
                                this.insertVirtualObjectFromDrag(dragData, e.clientX, e.clientY);

                                // ドラッグ元のウィンドウに「クロスウィンドウドロップ成功」を通知
                                window.parent.postMessage({
                                    type: 'cross-window-drop-success',
                                    mode: dragData.mode,
                                    source: dragData.source,
                                    sourceWindowId: dragData.sourceWindowId,
                                    virtualObjectId: dragData.virtualObject.link_id
                                }, '*');
                            } else {
                                // 同じウィンドウ内での移動：ドロップ位置を保存してdragendで使用
                                console.log('[VirtualObjectList] 同じウィンドウ内でのドロップ位置を保存:', e.clientX, e.clientY);
                                this.draggingState.dropClientX = e.clientX;
                                this.draggingState.dropClientY = e.clientY;
                                this.draggingState.hasMoved = true; // ドロップされたので移動したとみなす
                            }
                            return; // 処理完了
                        }
                    } catch (_jsonError) {
                        // JSON形式でない場合はスキップ
                        console.log('[VirtualObjectList] JSON形式でないドロップデータ');
                    }
                }
            } catch (error) {
                console.error('[VirtualObjectList] ドロップ処理エラー:', error);
            }
        });
    }

    /**
     * 原紙ファイルを仮身として挿入
     */
    insertBaseFileAsVirtualObject(baseFile, clientX, clientY) {
        console.log('[VirtualObjectList] 原紙ファイル挿入:', baseFile.displayName);

        // ドロップ位置を計算
        const listElement = document.getElementById('virtualList');
        const canvas = listElement.querySelector('.virtual-canvas');

        if (!canvas) {
            console.warn('[VirtualObjectList] キャンバスが見つかりません');
            return;
        }

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        // 仮身オブジェクトを作成
        const virtualObj = {
            link_id: baseFile.pluginId,
            link_name: baseFile.displayName,
            vobjleft: Math.max(0, x - 75), // 中央に配置
            vobjtop: Math.max(0, y - 15),
            vobjright: Math.max(0, x + 75),
            vobjbottom: Math.max(0, y + 15),
            width: 150,
            height_px: 30,
            chsz: 14,
            frcol: '#000000',
            chcol: '#000000',
            tbcol: '#ffffff',
            bgcol: '#ffffff',
            dlen: 0
        };

        // 仮身リストに追加
        this.virtualObjects.push(virtualObj);

        // xmlTADに追加
        this.addVirtualObjectToXml(virtualObj);

        // 再描画
        this.renderVirtualObjects();

        console.log('[VirtualObjectList] 原紙ファイル挿入完了');
    }

    /**
     * unpack-fileから書庫ファイルがドロップされた時の処理
     * ドロップ位置情報のみをunpack-fileに返す（確認ダイアログはunpack-fileが表示）
     */
    async insertArchiveFileAsVirtualObject(dragData, clientX, clientY) {
        console.log('[VirtualObjectList] 書庫ファイルドロップ検出:', dragData.file.name);

        // ドロップ位置を計算
        const listElement = document.getElementById('virtualList');
        const canvas = listElement.querySelector('.virtual-canvas');

        if (!canvas) {
            console.warn('[VirtualObjectList] キャンバスが見つかりません');
            return;
        }

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        // ドロップ位置情報をunpack-fileに通知（確認ダイアログはunpack-fileが表示）
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'archive-drop-detected',
                dropPosition: { x, y },
                dragData: dragData
            }, '*');
        }
    }

    /**
     * ドラッグ&ドロップされた仮身を挿入
     * @param {Object} dragData - ドラッグデータ
     * @param {number} clientX - ドロップ位置X
     * @param {number} clientY - ドロップ位置Y
     */
    insertVirtualObjectFromDrag(dragData, clientX, clientY) {
        console.log('[VirtualObjectList] 仮身ドロップ受信:', dragData.virtualObject.link_name, 'モード:', dragData.mode, 'ソースウィンドウID:', dragData.sourceWindowId, '現在のウィンドウID:', this.windowId);

        // 同じウィンドウ内からのドラッグの場合、既にmouseupイベントで位置更新済み
        // 重複して<link>を追加しないようにする
        const isSameWindow = dragData.sourceWindowId === this.windowId;
        if (dragData.mode === 'move' && isSameWindow) {
            console.log('[VirtualObjectList] 同じウィンドウ内の移動モード: mouseupイベントで既に処理済みのためスキップ');
            return;
        }

        // コピーモード、または別ウィンドウからの移動モードの場合は新しい仮身を追加
        console.log('[VirtualObjectList] 新しい仮身を挿入:', isSameWindow ? 'コピーモード' : '別ウィンドウからの移動/コピー');

        // ドロップ位置を計算
        const listElement = document.getElementById('virtualList');
        const canvas = listElement.querySelector('.virtual-canvas');

        if (!canvas) {
            console.warn('[VirtualObjectList] キャンバスが見つかりません');
            return;
        }

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        // 仮身オブジェクトを作成
        const virtualObj = {
            link_id: dragData.virtualObject.link_id,
            link_name: dragData.virtualObject.link_name,
            vobjleft: Math.max(0, x - (dragData.virtualObject.width / 2)),
            vobjtop: Math.max(0, y - (dragData.virtualObject.height_px / 2)),
            vobjright: Math.max(0, x + (dragData.virtualObject.width / 2)),
            vobjbottom: Math.max(0, y + (dragData.virtualObject.height_px / 2)),
            width: dragData.virtualObject.width,
            height_px: dragData.virtualObject.height_px,
            chsz: dragData.virtualObject.chsz,
            frcol: dragData.virtualObject.frcol,
            chcol: dragData.virtualObject.chcol,
            tbcol: dragData.virtualObject.tbcol,
            bgcol: dragData.virtualObject.bgcol,
            dlen: dragData.virtualObject.dlen,
            applist: dragData.virtualObject.applist || {},
            // 新しく作成された仮身なので、元の位置は現在の位置と同じ
            originalLeft: Math.max(0, x - (dragData.virtualObject.width / 2)),
            originalTop: Math.max(0, y - (dragData.virtualObject.height_px / 2)),
            originalRight: Math.max(0, x + (dragData.virtualObject.width / 2)),
            originalBottom: Math.max(0, y + (dragData.virtualObject.height_px / 2))
        };

        // 仮身リストに追加
        this.virtualObjects.push(virtualObj);

        // xmlTADに追加
        this.addVirtualObjectToXml(virtualObj);

        // 再描画
        this.renderVirtualObjects();

        // コピーモードの場合はrefCount+1
        if (dragData.mode === 'copy') {
            this.requestCopyVirtualObject(virtualObj.link_id);
        }

        // キャンバスサイズとスクロールバーを更新
        this.updateCanvasSize();

        console.log('[VirtualObjectList] 仮身挿入完了');
    }

    /**
     * unpack-fileからルート実身配置要求を受け取る
     * @param {Object} rootFileData - ルート実身のデータ
     * @param {number} x - 配置位置X
     * @param {number} y - 配置位置Y
     */
    insertRootVirtualObject(rootFileData, x, y) {
        console.log('[VirtualObjectList] ルート実身を配置:', rootFileData.name);
        console.log('[VirtualObjectList] rootFileData.applist:', rootFileData.applist);

        // 仮身オブジェクトを作成
        const virtualObj = {
            link_id: rootFileData.fileId,
            link_name: rootFileData.name,
            vobjleft: Math.max(0, x - 75),
            vobjtop: Math.max(0, y - 15),
            vobjright: Math.max(0, x + 75),
            vobjbottom: Math.max(0, y + 15),
            width: 150,
            height_px: 30,
            chsz: 14,
            frcol: '#000000',
            chcol: '#000000',
            tbcol: '#ffffff',
            bgcol: '#ffffff',
            dlen: 0,
            applist: rootFileData.applist || {},  // applist情報を設定
            // 新しく作成された仮身なので、元の位置は現在の位置と同じ
            originalLeft: Math.max(0, x - 75),
            originalTop: Math.max(0, y - 15),
            originalRight: Math.max(0, x + 75),
            originalBottom: Math.max(0, y + 15)
        };

        // 仮身リストに追加
        this.virtualObjects.push(virtualObj);

        // xmlTADに追加
        this.addVirtualObjectToXml(virtualObj);

        // 再描画
        this.renderVirtualObjects();

        console.log('[VirtualObjectList] ルート実身配置完了');

        // unpack-fileに配置完了を通知
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'root-virtual-object-inserted',
                success: true
            }, '*');
        }
    }

    /**
     * 原紙箱から実身IDと名前を受け取って仮身を追加
     * @param {string} realId - 実身ID
     * @param {string} name - 実身名
     * @param {Object} dropPosition - ドロップ位置 {x, y}
     * @param {Object} applist - アプリケーションリスト
     */
    addVirtualObjectFromRealId(realId, name, dropPosition, applist) {
        console.log('[VirtualObjectList] 実身IDから仮身を追加:', realId, name, dropPosition, 'applist:', applist);

        // ドロップ位置を計算
        let x = 100;
        let y = 100 + (this.virtualObjects.length * 40);

        if (dropPosition) {
            // dropPositionはiframe内のクライアント座標なので、キャンバス座標に変換
            const listElement = document.getElementById('virtualList');
            const canvas = listElement ? listElement.querySelector('.virtual-canvas') : null;

            if (canvas) {
                const rect = canvas.getBoundingClientRect();
                x = dropPosition.x - rect.left;
                y = dropPosition.y - rect.top;
                console.log('[VirtualObjectList] ドロップ位置をキャンバス座標に変換:', {clientX: dropPosition.x, clientY: dropPosition.y, canvasX: x, canvasY: y});
            } else {
                console.warn('[VirtualObjectList] キャンバスが見つかりません、デフォルト位置を使用');
            }
        }

        // 仮身オブジェクトを作成（ドロップ位置に配置）
        const virtualObj = {
            link_id: `${realId}_0.xtad`,
            link_name: name,
            vobjleft: Math.max(0, x - 75), // 中央に配置
            vobjtop: Math.max(0, y - 15),
            vobjright: Math.max(0, x + 75),
            vobjbottom: Math.max(0, y + 15),
            width: 150,
            height_px: 30,
            chsz: 14,
            frcol: '#000000',
            chcol: '#000000',
            tbcol: '#ffffff',
            bgcol: '#ffffff',
            dlen: 0,
            applist: applist || {},  // 親ウィンドウから渡されたapplist情報を使用
            // 新しく作成された仮身なので、元の位置は現在の位置と同じ
            originalLeft: Math.max(0, x - 75),
            originalTop: Math.max(0, y - 15),
            originalRight: Math.max(0, x + 75),
            originalBottom: Math.max(0, y + 15)
        };

        // 仮身リストに追加
        this.virtualObjects.push(virtualObj);

        // xmlTADに追加
        this.addVirtualObjectToXml(virtualObj);

        // 再描画
        this.renderVirtualObjects();

        console.log('[VirtualObjectList] 実身IDから仮身を追加完了:', realId, name);
    }

    /**
     * メッセージダイアログを表示（親ウィンドウのshowMessageDialogを利用）
     * @param {string} message - メッセージ
     * @param {Array} buttons - ボタン配列 [{ label, value }, ...]
     * @param {number} defaultButton - デフォルトボタンのインデックス
     * @returns {Promise<string>} - 選択されたボタンのvalue
     */
    async showMessageDialog(message, buttons, defaultButton = 0) {
        return new Promise((resolve) => {
            const messageId = `msg_${Date.now()}_${Math.random()}`;

            const handler = (event) => {
                if (event.data && event.data.type === 'message-dialog-response' && event.data.messageId === messageId) {
                    window.removeEventListener('message', handler);
                    resolve(event.data.result);
                }
            };

            window.addEventListener('message', handler);

            // 親ウィンドウにメッセージダイアログ表示を要求
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'show-message-dialog',
                    messageId: messageId,
                    message: message,
                    buttons: buttons,
                    defaultButton: defaultButton
                }, '*');
            }
        });
    }

    setupMessageHandler() {
        window.addEventListener('message', async (event) => {
            if (event.data && event.data.type === 'init') {
                console.log('[VirtualObjectList] init受信', event.data);

                this.fileData = event.data.fileData;
                console.log('[VirtualObjectList] fileData:', this.fileData);
                // realId (新規作成時) または fileId (デフォルトウィンドウ) のいずれかを使用
                const realIdValue = this.fileData ? (this.fileData.realId || this.fileData.fileId) : null;
                console.log('[VirtualObjectList] fileData.realId:', this.fileData ? this.fileData.realId : 'null', 'fileData.fileId:', this.fileData ? this.fileData.fileId : 'null');
                this.fileId = realIdValue;
                console.log('[VirtualObjectList] this.fileId設定完了:', this.fileId);

                // 全画面表示状態を復元
                if (this.fileData && this.fileData.isFullscreen !== undefined) {
                    this.isFullscreen = this.fileData.isFullscreen;
                    console.log('[VirtualObjectList] 全画面表示状態を復元:', this.isFullscreen);
                }

                // XMLデータを取得
                if (this.fileData.xmlData) {
                    this.xmlData = this.fileData.xmlData;
                    this.tadData = this.fileData.xmlData;
                    await this.parseVirtualObjects();
                    this.renderVirtualObjects();
                }

                // キーボードショートカットが動作するようにbodyにフォーカスを設定
                setTimeout(() => {
                    document.body.focus();
                    console.log('[VirtualObjectList] bodyにフォーカスを設定');
                }, 100);
            } else if (event.data && event.data.type === 'load-virtual-object') {
                // 開いた仮身として起動された場合
                console.log('[VirtualObjectList] load-virtual-object受信', event.data);

                // readonlyモードの設定（開いた仮身表示用）
                if (event.data.readonly === true) {
                    this.isReadonly = true;
                    console.log('[VirtualObjectList] 読み取り専用モードを適用');
                }

                // スクロールバー非表示モードの設定（開いた仮身表示用）
                if (event.data.noScrollbar === true) {
                    this.noScrollbar = true;
                    document.body.style.overflow = 'hidden';
                    const pluginContent = document.querySelector('.plugin-content');
                    if (pluginContent) {
                        pluginContent.style.overflow = 'hidden';
                    }
                    const viewerContainer = document.querySelector('.viewer-container');
                    if (viewerContainer) {
                        viewerContainer.style.overflow = 'hidden';
                    }
                    console.log('[VirtualObjectList] スクロールバー非表示モードを適用');
                }

                // realObjectからXMLデータを取得
                if (event.data.realObject && event.data.realObject.records && event.data.realObject.records.length > 0) {
                    const firstRecord = event.data.realObject.records[0];

                    // records[0].xtadまたはrecords[0].dataからXMLデータを取得
                    // btron-desktop.jsではxtadに保存されている
                    this.xmlData = firstRecord.xtad || firstRecord.data;
                    this.tadData = this.xmlData;

                    console.log('[VirtualObjectList] XMLデータ設定完了:', this.xmlData ? this.xmlData.substring(0, 200) : 'なし');

                    // 背景色を設定
                    if (event.data.bgcol) {
                        this.bgcol = event.data.bgcol;
                        console.log('[VirtualObjectList] 背景色設定:', this.bgcol);
                    } else {
                        console.log('[VirtualObjectList] 背景色が設定されていません');
                    }

                    // XMLデータを解析して仮身をレンダリング
                    await this.parseVirtualObjects();
                    this.renderVirtualObjects();

                    console.log('[VirtualObjectList] 開いた仮身として起動完了');
                } else {
                    console.log('[VirtualObjectList] realObjectデータがありません:', {
                        hasRealObject: !!event.data.realObject,
                        hasRecords: !!(event.data.realObject && event.data.realObject.records),
                        recordsLength: event.data.realObject && event.data.realObject.records ? event.data.realObject.records.length : 0
                    });
                }
            } else if (event.data && event.data.type === 'load-data') {
                // 開いた仮身表示用のデータ受信（appListのdefaultOpenから）
                console.log('[VirtualObjectList] load-data受信:', event.data);

                // readonlyモードの設定
                if (event.data.readonly === true) {
                    this.isReadonly = true;
                    console.log('[VirtualObjectList] 読み取り専用モードを適用');
                }

                // スクロールバー非表示モードの設定
                if (event.data.noScrollbar === true) {
                    this.noScrollbar = true;
                    document.body.style.overflow = 'hidden';
                    const pluginContent = document.querySelector('.plugin-content');
                    if (pluginContent) {
                        pluginContent.style.overflow = 'hidden';
                    }
                    const viewerContainer = document.querySelector('.viewer-container');
                    if (viewerContainer) {
                        viewerContainer.style.overflow = 'hidden';
                    }
                    console.log('[VirtualObjectList] スクロールバー非表示モードを適用');
                }

                // 背景色の設定
                if (event.data.bgcol) {
                    this.bgcol = event.data.bgcol;
                    console.log('[VirtualObjectList] 背景色を設定:', this.bgcol);
                }

                // realObjectからXMLデータを取得
                if (event.data.realObject && event.data.realObject.records && event.data.realObject.records.length > 0) {
                    const firstRecord = event.data.realObject.records[0];
                    this.xmlData = firstRecord.xtad || firstRecord.data;
                    this.tadData = this.xmlData;

                    console.log('[VirtualObjectList] XMLデータ設定完了:', this.xmlData ? this.xmlData.substring(0, 200) : 'なし');

                    // XMLデータを解析して仮身をレンダリング
                    await this.parseVirtualObjects();
                    this.renderVirtualObjects();

                    // 背景色を適用
                    this.applyBackgroundColor();

                    console.log('[VirtualObjectList] load-dataで起動完了');
                } else {
                    console.log('[VirtualObjectList] realObjectデータがありません');
                }
            } else if (event.data && event.data.type === 'get-menu-definition') {
                // メニュー定義を動的に生成
                console.log('[VirtualObjectList] get-menu-definition受信, messageId:', event.data.messageId);
                const menuDefinition = this.getMenuDefinition();
                console.log('[VirtualObjectList] メニュー定義を生成:', menuDefinition);
                window.parent.postMessage({
                    type: 'menu-definition-response',
                    messageId: event.data.messageId,
                    menuDefinition: menuDefinition
                }, '*');
                console.log('[VirtualObjectList] menu-definition-response送信');
            } else if (event.data && event.data.type === 'menu-action') {
                this.handleMenuAction(event.data.action);
            } else if (event.data && event.data.type === 'add-virtual-object') {
                // 仮身を追加
                console.log('[VirtualObjectList] 仮身追加要求受信:', event.data.file);
                await this.addVirtualObjectFromFile(event.data.file);
            } else if (event.data && event.data.type === 'insert-root-virtual-object') {
                // unpack-fileからルート実身配置要求を受信
                console.log('[VirtualObjectList] ルート実身配置要求受信:', event.data.rootFileData);
                this.insertRootVirtualObject(event.data.rootFileData, event.data.x, event.data.y);
            } else if (event.data && event.data.type === 'add-virtual-object-from-base') {
                // 原紙箱から仮身追加要求を受信
                console.log('[VirtualObjectList] 原紙箱から仮身追加:', event.data.realId, event.data.name, event.data.dropPosition, 'applist:', event.data.applist);
                this.addVirtualObjectFromRealId(event.data.realId, event.data.name, event.data.dropPosition, event.data.applist);
            } else if (event.data && event.data.type === 'add-virtual-object-from-trash') {
                // 屑実身操作から仮身追加要求を受信
                console.log('[VirtualObjectList] 屑実身操作から仮身追加:', event.data.realId, event.data.name, event.data.dropPosition, 'applist:', event.data.applist);
                this.addVirtualObjectFromRealId(event.data.realId, event.data.name, event.data.dropPosition, event.data.applist);
            } else if (event.data && event.data.type === 'input-dialog-response') {
                // ダイアログレスポンスを処理
                if (this.dialogCallbacks && this.dialogCallbacks[event.data.messageId]) {
                    this.dialogCallbacks[event.data.messageId](event.data.result);
                    delete this.dialogCallbacks[event.data.messageId];
                }
            } else if (event.data && event.data.type === 'window-closed') {
                // ウィンドウが閉じたことを通知
                this.handleWindowClosed(event.data.windowId, event.data.fileData);
            } else if (event.data && event.data.type === 'message-dialog-response') {
                // メッセージダイアログレスポンスを処理
                if (this.dialogCallbacks && this.dialogCallbacks[event.data.messageId]) {
                    this.dialogCallbacks[event.data.messageId](event.data.result);
                    delete this.dialogCallbacks[event.data.messageId];
                }
            } else if (event.data && event.data.type === 'window-resized') {
                // ウインドウリサイズ時にキャンバスサイズのみ更新（開いた仮身を保持）
                this.updateCanvasSize();
            } else if (event.data && event.data.type === 'window-moved') {
                // ウィンドウ移動終了時にwindowConfigを更新
                this.updateWindowConfig({
                    pos: event.data.pos,
                    width: event.data.width,
                    height: event.data.height
                });
            } else if (event.data && event.data.type === 'window-resized-end') {
                // ウィンドウリサイズ終了時にwindowConfigを更新
                this.updateWindowConfig({
                    pos: event.data.pos,
                    width: event.data.width,
                    height: event.data.height
                });
            } else if (event.data && event.data.type === 'window-maximize-toggled') {
                console.log('[VirtualObjectList] window-maximize-toggled受信:', event.data.maximize, 'width:', event.data.width, 'height:', event.data.height);

                // 全画面表示切り替え時にwindowConfigを更新
                this.updateWindowConfig({
                    pos: event.data.pos,
                    width: event.data.width,
                    height: event.data.height,
                    maximize: event.data.maximize
                });
            } else if (event.data && event.data.type === 'window-maximize-completed') {
                // CSSアニメーション完了後に呼ばれる
                console.log('[VirtualObjectList] window-maximize-completed受信:', event.data.maximize, 'width:', event.data.width, 'height:', event.data.height);

                // 全画面表示をオンにした場合、描画領域を拡大
                if (event.data.maximize) {
                    console.log('[VirtualObjectList] 全画面表示完了 - renderVirtualObjects()を実行');
                    this.renderVirtualObjects();
                } else {
                    console.log('[VirtualObjectList] 全画面解除完了 - shrinkCanvasIfNeeded()を実行');
                    // 全画面表示をオフにした場合、キャンバスサイズを縮小（必要に応じて）
                    this.shrinkCanvasIfNeeded();
                }
            } else if (event.data && event.data.type === 'parent-drag-position') {
                // 親ウィンドウからドラッグ位置情報を受信
                this.handleParentDragPosition(event.data);
            } else if (event.data && event.data.type === 'cross-window-drop-completed') {
                // 別ウィンドウへのドロップ完了通知
                console.log('[VirtualObjectList] cross-window-drop-completed受信:', event.data);
                this.lastDropWasCrossWindow = true;
                this.crossWindowDropMode = event.data.mode;
            } else if (event.data && event.data.type === 'check-window-id') {
                // 親ウィンドウからのウィンドウID確認
                if (event.data.targetWindowId === this.windowId) {
                    console.log('[VirtualObjectList] ウィンドウID一致！クロスウィンドウドロップ完了を設定');
                    this.lastDropWasCrossWindow = true;
                    this.crossWindowDropMode = event.data.dropData.mode;
                }
            } else if (event.data && event.data.type === 'update-background-color') {
                // 背景色更新（開いた仮身の場合）
                console.log('[VirtualObjectList] 背景色更新受信:', event.data.bgcol);
                if (event.data.bgcol) {
                    this.bgcol = event.data.bgcol;
                    this.applyBackgroundColor();
                }
            } else if (event.data && event.data.type === 'load-data-file-request') {
                // 開いた仮身内のプラグインからのファイル読み込み要求を親ウィンドウに転送
                console.log('[VirtualObjectList] load-data-file-request受信、親ウィンドウに転送:', event.data.fileName);
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage(event.data, '*');
                }
            } else if (event.data && event.data.type === 'load-data-file-response') {
                // 親ウィンドウからのファイル読み込みレスポンスを開いた仮身内のプラグインに転送
                console.log('[VirtualObjectList] load-data-file-response受信、子iframeに転送:', event.data.fileName);
                // すべての子iframeに転送（requestIdで識別されるので問題ない）
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach(iframe => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage(event.data, '*');
                    }
                });
            } else if (event.data && event.data.type === 'read-icon-file') {
                // 開いた仮身内のプラグインからのアイコン読み込み要求を親ウィンドウに転送
                console.log('[VirtualObjectList] read-icon-file受信、親ウィンドウに転送:', event.data.realId);
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage(event.data, '*');
                }
            } else if (event.data && event.data.type === 'icon-file-loaded') {
                // 親ウィンドウからのアイコン読み込みレスポンスを開いた仮身内のプラグインに転送
                console.log('[VirtualObjectList] icon-file-loaded受信、子iframeに転送:', event.data.realId);
                // すべての子iframeに転送（realIdで識別されるので問題ない）
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach(iframe => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage(event.data, '*');
                    }
                });
            }
        });
    }

    /**
     * 親ウィンドウからドラッグ位置情報を受信し、位置を更新
     * @param {Object} data - { isOverThisWindow, clientX, clientY, relativeX, relativeY }
     */
    handleParentDragPosition(data) {
        console.log('[VirtualObjectList] parent-drag-position受信:', {
            isOverThisWindow: data.isOverThisWindow,
            isDragging: this.draggingState.isDragging,
            hasMoved: this.draggingState.hasMoved,
            dragMode: this.draggingState.dragMode,
            windowId: this.windowId
        });

        // ドラッグ中でない、または移動していない場合はスキップ
        if (!this.draggingState.isDragging || !this.draggingState.hasMoved) return;
        if (!this.draggingState.currentElement) return;

        // 親ウィンドウから通知された isOverThisWindow フラグに基づいて表示/非表示を制御
        if (data.isOverThisWindow) {
            // このウィンドウの上にマウスがある場合のみ位置を更新
            const deltaX = this.draggingState.currentDeltaX || 0;
            const deltaY = this.draggingState.currentDeltaY || 0;

            const newLeft = this.draggingState.initialLeft + deltaX;
            const newTop = this.draggingState.initialTop + deltaY;

            this.draggingState.currentElement.style.left = newLeft + 'px';
            this.draggingState.currentElement.style.top = newTop + 'px';
            this.draggingState.currentElement.style.visibility = 'visible';
            console.log('[VirtualObjectList] 仮身を表示:', this.draggingState.currentObject.link_name);
        } else {
            // このウィンドウの上にマウスがない場合
            // コピーモードの場合は元の仮身を表示したまま、移動モードの場合のみ非表示
            if (this.draggingState.dragMode === 'copy') {
                // コピーモードの場合は元の仮身を表示したまま
                this.draggingState.currentElement.style.left = this.draggingState.initialLeft + 'px';
                this.draggingState.currentElement.style.top = this.draggingState.initialTop + 'px';
                this.draggingState.currentElement.style.visibility = 'visible';
                console.log('[VirtualObjectList] コピーモード: 仮身を表示したまま:', this.draggingState.currentObject.link_name);
            } else {
                // 移動モードの場合は非表示
                this.draggingState.currentElement.style.visibility = 'hidden';
                console.log('[VirtualObjectList] 移動モード: 仮身を非表示:', this.draggingState.currentObject.link_name);
            }
        }
    }

    /**
     * メニュー定義を動的に生成
     * 選択された仮身のappList情報を元に「実行」メニューを作成
     */
    getMenuDefinition() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        console.log('[VirtualObjectList] getMenuDefinition呼び出し, 選択中の仮身:', selectedVirtualObject ? selectedVirtualObject.link_name : 'なし');

        // 読み取り専用モードの場合は、表示系メニューのみ表示
        const menuDefinition = this.isReadonly ? [
            {
                text: '表示',
                submenu: [
                    { text: '全画面表示', action: 'toggle-fullscreen', shortcut: 'Ctrl+L' },
                    { text: '再表示', action: 'refresh' }
                ]
            }
        ] : [
            { text: '保存', action: 'save', shortcut: 'Ctrl+S' },
            {
                text: '表示',
                submenu: [
                    { text: '全画面表示', action: 'toggle-fullscreen', shortcut: 'Ctrl+L' },
                    { text: '再表示', action: 'refresh' },
                    { text: '背景色変更', action: 'change-bg-color' }
                ]
            },
            {
                text: '編集',
                submenu: [
                    { text: '取消', action: 'undo' },
                    { text: 'クリップボードへコピー', action: 'copy', shortcut: 'Ctrl+C' },
                    { text: 'クリップボードからコピー', action: 'paste', shortcut: 'Ctrl+V' },
                    { text: 'クリップボードへ移動', action: 'cut', shortcut: 'Ctrl+X' },
                    { text: 'クリップボードから移動', action: 'redo', shortcut: 'Ctrl+Z' },
                    { separator: true },
                    { text: '削除', action: 'delete', shortcut: 'Delete' },
                    { separator: true },
                    { text: 'いちばん前へ移動', action: 'front', shortcut: 'Ctrl+F' },
                    { text: 'いちばん後ろへ移動', action: 'back', shortcut: 'Ctrl+R' },
                    { separator: true },
                    { text: '整頓', action: 'arrange-virtual-objects', disabled: this.selectedVirtualObjects.size === 0 }
                ]
            }
        ];

        // 仮身が選択されている場合は「仮身操作」メニューを追加（読み取り専用モードでは非表示）
        if (selectedVirtualObject && !this.isReadonly) {
            const realId = selectedVirtualObject.link_id;
            const isOpened = this.openedRealObjects.has(realId);

            const virtualObjSubmenu = [
                { text: '開く', action: 'open-real-object', disabled: isOpened },
                { text: '閉じる', action: 'close-real-object', disabled: !isOpened },
                { separator: true },
                { text: '属性変更', action: 'change-virtual-object-attributes' }
            ];

            menuDefinition.push({
                text: '仮身操作',
                submenu: virtualObjSubmenu
            });

            // 「実身操作」メニューを追加
            const realObjSubmenu = [
                { text: '実身名変更', action: 'rename-real-object' },
                { text: '実身複製', action: 'duplicate-real-object' }
            ];

            menuDefinition.push({
                text: '実身操作',
                submenu: realObjSubmenu
            });

            // 「屑実身操作」メニューを追加
            menuDefinition.push({
                text: '屑実身操作',
                action: 'open-trash-real-objects'
            });
        }

        // 仮身が選択されている場合は「実行」メニューを追加
        if (selectedVirtualObject && selectedVirtualObject.applist && typeof selectedVirtualObject.applist === 'object') {
            // applistオブジェクトからプラグインIDの配列を取得
            const pluginIds = Object.keys(selectedVirtualObject.applist);

            // btron-desktop.jsに登録されているプラグインのみをフィルタリング
            const availablePlugins = pluginIds.filter(pluginId => {
                return this.isPluginRegistered(pluginId);
            });

            if (availablePlugins.length > 0) {
                const executeSubmenu = availablePlugins.map(pluginId => {
                    // appListオブジェクトからnameを取得（なければpluginIdをそのまま使用）
                    const pluginInfo = selectedVirtualObject.applist[pluginId];
                    const displayName = (pluginInfo && pluginInfo.name) ? pluginInfo.name : pluginId;

                    return {
                        text: displayName,
                        action: `execute-with-${pluginId}`
                    };
                });

                menuDefinition.push({
                    text: '実行',
                    submenu: executeSubmenu
                });
            }
        }

        return menuDefinition;
    }

    /**
     * プラグインがbtron-desktop.jsに登録されているか確認
     */
    isPluginRegistered(pluginId) {
        // 親ウィンドウのpluginManagerに問い合わせる
        if (window.parent && window.parent.pluginManager) {
            return window.parent.pluginManager.plugins.has(pluginId);
        }
        return false;
    }

    handleMenuAction(action) {
        // 「実行」メニューの処理（execute-with-で始まるアクション）
        if (action.startsWith('execute-with-')) {
            const pluginId = action.replace('execute-with-', '');
            this.executeVirtualObjectWithPlugin(pluginId);
            return;
        }

        switch (action) {
            case 'save':
                this.saveToFile();
                break;
            case 'toggle-fullscreen':
                this.toggleFullscreen();
                break;
            case 'refresh':
                this.refresh();
                break;
            case 'change-bg-color':
                this.changeBgColor();
                break;
            case 'copy':
                this.copySelectedVirtualObject();
                break;
            case 'paste':
                this.pasteVirtualObject();
                break;
            case 'cut':
                this.cutSelectedVirtualObject();
                break;
            case 'delete':
                this.deleteSelectedVirtualObject();
                break;
            case 'front':
                this.moveSelectedVirtualObjectToFront();
                break;
            case 'back':
                this.moveSelectedVirtualObjectToBack();
                break;
            case 'arrange-virtual-objects':
                this.showArrangeDialog();
                break;
            case 'undo':
                // TODO: Undo機能
                console.log('[VirtualObjectList] Undo未実装');
                break;
            case 'redo':
                // TODO: Redo機能
                console.log('[VirtualObjectList] Redo未実装');
                break;
            case 'open-real-object':
                this.openRealObjectWithDefaultApp();
                break;
            case 'close-real-object':
                this.closeRealObject();
                break;
            case 'change-virtual-object-attributes':
                this.changeVirtualObjectAttributes();
                break;
            case 'rename-real-object':
                this.renameRealObject();
                break;
            case 'duplicate-real-object':
                this.duplicateRealObject();
                break;
            case 'open-trash-real-objects':
                this.openTrashRealObjects();
                break;
        }
    }

    /**
     * 選択された仮身の実身を指定されたプラグインで開く
     */
    executeVirtualObjectWithPlugin(pluginId) {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 仮身が選択されていません');
            return;
        }

        const realId = selectedVirtualObject.link_id;
        console.log('[VirtualObjectList] 仮身の実身を開く:', realId, 'プラグイン:', pluginId);

        // ウィンドウが開いた通知を受け取るハンドラー
        const messageId = `open-${realId}-${Date.now()}`;
        const handleWindowOpened = (e) => {
            if (e.data && e.data.type === 'window-opened' && e.data.messageId === messageId) {
                window.removeEventListener('message', handleWindowOpened);

                if (e.data.success && e.data.windowId) {
                    // 開いたウィンドウを追跡
                    this.openedRealObjects.set(realId, e.data.windowId);
                    console.log('[VirtualObjectList] ウィンドウが開きました:', e.data.windowId, 'realId:', realId);

                    // ウィンドウのアイコンを設定
                    // realIdから_0.xtadなどのサフィックスを除去して基本実身IDを取得
                    let baseRealId = realId.replace(/\.(xtad|json)$/, '').replace(/_\d+$/, '');
                    const iconPath = `${baseRealId}.ico`;
                    if (window.parent && window.parent !== window) {
                        window.parent.postMessage({
                            type: 'set-window-icon',
                            windowId: e.data.windowId,
                            iconPath: iconPath
                        }, '*');
                        console.log('[VirtualObjectList] ウィンドウアイコン設定要求:', e.data.windowId, iconPath);
                    }
                }
            }
        };

        window.addEventListener('message', handleWindowOpened);

        // 親ウィンドウ(btron-desktop.js)に実身を開くよう要求
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'open-virtual-object-real',
                virtualObj: selectedVirtualObject,
                pluginId: pluginId,
                messageId: messageId
            }, '*');
        }
    }

    /**
     * 選択中の仮身を最前面に移動
     */
    moveSelectedVirtualObjectToFront() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        console.log('[VirtualObjectList] 仮身を最前面に移動:', selectedVirtualObject.link_name);

        // 現在の最大z-indexを見つける
        let maxZIndex = 0;
        const allVirtualObjects = document.querySelectorAll('.virtual-object');
        allVirtualObjects.forEach(el => {
            const zIndex = parseInt(el.style.zIndex) || 0;
            if (zIndex > maxZIndex) {
                maxZIndex = zIndex;
            }
        });

        // 選択中の仮身のDOM要素を見つけてz-indexを最大値+1に設定
        allVirtualObjects.forEach(el => {
            // data属性やクラスで識別する代わりに、位置で識別
            const left = parseInt(el.style.left);
            const top = parseInt(el.style.top);

            if (left === selectedVirtualObject.vobjleft && top === selectedVirtualObject.vobjtop) {
                el.style.zIndex = (maxZIndex + 1).toString();
                console.log('[VirtualObjectList] z-indexを設定:', maxZIndex + 1);
            }
        });
    }

    /**
     * 選択中の仮身を最背面に移動
     */
    moveSelectedVirtualObjectToBack() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        console.log('[VirtualObjectList] 仮身を最背面に移動:', selectedVirtualObject.link_name);

        // 選択中の仮身のDOM要素を見つけてz-indexを0に設定
        const allVirtualObjects = document.querySelectorAll('.virtual-object');
        allVirtualObjects.forEach(el => {
            // data属性やクラスで識別する代わりに、位置で識別
            const left = parseInt(el.style.left);
            const top = parseInt(el.style.top);

            if (left === selectedVirtualObject.vobjleft && top === selectedVirtualObject.vobjtop) {
                el.style.zIndex = '0';
                console.log('[VirtualObjectList] z-indexを0に設定');
            }
        });
    }

    /**
     * ファイルから仮身を追加
     * @param {Object} file - ファイル情報
     */
    async addVirtualObjectFromFile(file) {
        try {
            // ファイル名から拡張子を除いたIDを生成
            const fileId = file.name.replace(/\.(tad|TAD|xtad|XTAD|bpk|BPK)$/, '');

            // 新しい仮身オブジェクトを作成（適当な位置に配置）
            const newVirtualObject = {
                link_id: file.name,
                link_name: fileId,
                vobjleft: 100,
                vobjtop: 100, // 既存の仮身の下に配置
                vobjright: 250,
                vobjbottom: 130,
                width: 100,
                height_px: 50,
                chsz: 16,           // デフォルトフォントサイズ
                frcol: '#000000',   // デフォルト枠色
                chcol: '#000000',   // デフォルト文字色
                tbcol: '#ffffff',   // デフォルト背景色
                bgcol: '#ffffff',   // デフォルト開いた仮身の背景色
                applist: {}, // メタデータは後で読み込み
                metadata: null
            };

            // BPK/TADファイルかどうかを判定
            const isBPK = /\.(bpk|BPK)$/.test(file.name);
            const isTAD = /\.(tad|TAD)$/.test(file.name);

            // BPK/TADファイル以外はメタデータを読み込み
            if (!isBPK && !isTAD) {
                await this.loadVirtualObjectMetadata(newVirtualObject);
            }

            // JSONファイルが無い場合（bpk/tadファイル）、デフォルトでtadjs-viewを設定
            if (!newVirtualObject.applist || Object.keys(newVirtualObject.applist).length === 0) {
                // BPKファイルの場合はunpack-fileも追加
                if (isBPK) {
                    newVirtualObject.applist = {
                        'tadjs-view': {
                            'name': 'TADjs表示'
                        },
                        'unpack-file': {
                            'name': '書庫管理'
                        }
                    };
                } else {
                    newVirtualObject.applist = {
                        'tadjs-view': {
                            'name': 'TADjs表示'
                        }
                    };
                }
                console.log('[VirtualObjectList] デフォルトapplist設定:', newVirtualObject.applist);
            }

            // 仮身リストに追加
            this.virtualObjects.push(newVirtualObject);

            // 再描画
            this.renderVirtualObjects();

            console.log('[VirtualObjectList] 仮身を追加しました:', file.name);
        } catch (error) {
            console.error('[VirtualObjectList] 仮身追加エラー:', error);
        }
    }

    /**
     * ファイルに保存（ダウンロード）
     */
    saveToFile() {
        if (!this.xmlData) {
            console.warn('[VirtualObjectList] 保存するデータがありません');
            return;
        }

        // 親ウィンドウに保存を通知
        this.notifyXmlDataChanged();
        console.log('[VirtualObjectList] ファイル保存を実行');
    }

    /**
     * ウィンドウを閉じるリクエストを送信
     */
    requestCloseWindow() {
        if (window.parent && window.parent !== window) {
            // 親ウィンドウのiframe要素からwindowIdを取得
            const windowElement = window.frameElement ? window.frameElement.closest('.window') : null;
            const windowId = windowElement ? windowElement.id : null;

            if (windowId) {
                window.parent.postMessage({
                    type: 'close-window',
                    windowId: windowId
                }, '*');
            }
        }
    }

    /**
     * 選択中の仮身をコピー
     */
    copySelectedVirtualObject() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        // クリップボードに仮身データをコピー（実身IDを保持）
        const clipboardData = JSON.parse(JSON.stringify(selectedVirtualObject));

        // 親ウィンドウのグローバルクリップボードに設定
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'set-clipboard',
                clipboardData: clipboardData
            }, '*');
        }

        console.log('[VirtualObjectList] 仮身をクリップボードにコピー:', clipboardData.link_name, 'realId:', clipboardData.link_id);
    }

    /**
     * 選択中の仮身をカット
     */
    cutSelectedVirtualObject() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        // クリップボードにコピー
        const clipboardData = JSON.parse(JSON.stringify(selectedVirtualObject));

        // 親ウィンドウのグローバルクリップボードに設定
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'set-clipboard',
                clipboardData: clipboardData
            }, '*');
        }

        // 元の仮身を削除
        const index = this.virtualObjects.findIndex(obj => obj === selectedVirtualObject);
        if (index !== -1) {
            this.virtualObjects.splice(index, 1);
            this.selectedVirtualObjects.clear();
            this.renderVirtualObjects();
            console.log('[VirtualObjectList] 仮身をカット:', clipboardData.link_name);
        }
    }

    /**
     * クリップボードから仮身をペースト
     */
    async pasteVirtualObject() {
        // 親ウィンドウからクリップボードを取得
        const clipboard = await this.getClipboard();

        if (!clipboard) {
            console.warn('[VirtualObjectList] クリップボードが空です');
            return;
        }

        // 新しい仮身オブジェクトを作成（位置を少しずらす）
        const newVirtualObj = JSON.parse(JSON.stringify(clipboard));
        newVirtualObj.vobjleft += 20;
        newVirtualObj.vobjtop += 20;
        newVirtualObj.vobjright += 20;
        newVirtualObj.vobjbottom += 20;

        // 実身IDはそのまま使用（仮身の複製なので実身は共有）
        const realId = newVirtualObj.link_id;

        // 仮身リストに追加
        this.virtualObjects.push(newVirtualObj);

        // xmlTADに追加
        this.addVirtualObjectToXml(newVirtualObj);

        // 再描画
        this.renderVirtualObjects();

        // 親ウィンドウに仮身コピーを通知してrefCountを+1
        this.requestCopyVirtualObject(realId);

        console.log('[VirtualObjectList] 仮身をペースト:', newVirtualObj.link_name, 'realId:', realId);
    }

    /**
     * 親ウィンドウからクリップボードデータを取得
     * @returns {Promise<Object|null>}
     */
    getClipboard() {
        return new Promise((resolve) => {
            if (!window.parent || window.parent === window) {
                resolve(null);
                return;
            }

            const messageId = `get-clipboard-${Date.now()}-${Math.random()}`;

            const handleMessage = (e) => {
                if (e.data && e.data.type === 'clipboard-data' && e.data.messageId === messageId) {
                    window.removeEventListener('message', handleMessage);
                    resolve(e.data.clipboardData);
                }
            };

            window.addEventListener('message', handleMessage);

            window.parent.postMessage({
                type: 'get-clipboard',
                messageId: messageId
            }, '*');

            // タイムアウト処理（5秒）
            setTimeout(() => {
                window.removeEventListener('message', handleMessage);
                resolve(null);
            }, 5000);
        });
    }

    /**
     * 選択中の仮身を削除
     */
    deleteSelectedVirtualObject() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        const realId = selectedVirtualObject.link_id;
        const linkName = selectedVirtualObject.link_name;

        // 仮身リストから削除
        const index = this.virtualObjects.findIndex(obj => obj === selectedVirtualObject);
        if (index !== -1) {
            this.virtualObjects.splice(index, 1);
        }

        // xmlTADから削除
        this.removeVirtualObjectFromXml(selectedVirtualObject);

        // 選択解除
        this.selectedVirtualObjects.clear();

        // 再描画
        this.renderVirtualObjects();

        // 親ウィンドウに仮身削除を通知してrefCount-1
        this.requestDeleteVirtualObject(realId);

        console.log('[VirtualObjectList] 仮身を削除:', linkName, 'realId:', realId);
    }

    /**
     * 選択中の仮身が指し示す実身の名前を変更
     */
    async renameRealObject() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        const realId = selectedVirtualObject.link_id;
        const currentName = selectedVirtualObject.link_name;

        // 親ウィンドウにダイアログ表示を要求
        if (window.parent && window.parent !== window) {
            const messageId = `rename-real-${Date.now()}-${Math.random()}`;

            const handleMessage = (e) => {
                if (e.data && e.data.type === 'real-object-renamed' && e.data.messageId === messageId) {
                    window.removeEventListener('message', handleMessage);

                    if (e.data.success) {
                        // 仮身の表示名を更新
                        selectedVirtualObject.link_name = e.data.newName;
                        this.renderVirtualObjects();
                        console.log('[VirtualObjectList] 実身名変更成功:', realId, e.data.newName);
                    }
                }
            };

            window.addEventListener('message', handleMessage);

            window.parent.postMessage({
                type: 'rename-real-object',
                realId: realId,
                currentName: currentName,
                messageId: messageId
            }, '*');

            console.log('[VirtualObjectList] 実身名変更要求:', realId, currentName);
        }
    }

    /**
     * 選択中の仮身が指し示す実身を複製
     */
    async duplicateRealObject() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        const realId = selectedVirtualObject.link_id;

        // 親ウィンドウに実身複製を要求
        if (window.parent && window.parent !== window) {
            const messageId = `duplicate-real-${Date.now()}-${Math.random()}`;

            const handleMessage = (e) => {
                if (e.data && e.data.type === 'real-object-duplicated' && e.data.messageId === messageId) {
                    window.removeEventListener('message', handleMessage);

                    if (e.data.success) {
                        // 複製した実身の仮身を元の仮身の下に追加
                        const newVirtualObj = {
                            link_id: e.data.newRealId,
                            link_name: e.data.newName,
                            vobjleft: selectedVirtualObject.vobjleft + 20,
                            vobjtop: selectedVirtualObject.vobjtop + 30,
                            vobjright: selectedVirtualObject.vobjright + 20,
                            vobjbottom: selectedVirtualObject.vobjbottom + 30,
                            width: selectedVirtualObject.width,
                            height_px: selectedVirtualObject.height_px,
                            chsz: selectedVirtualObject.chsz,
                            frcol: selectedVirtualObject.frcol,
                            chcol: selectedVirtualObject.chcol,
                            tbcol: selectedVirtualObject.tbcol,
                            bgcol: selectedVirtualObject.bgcol,
                            dlen: selectedVirtualObject.dlen,
                            applist: selectedVirtualObject.applist || {}
                        };

                        // 仮身リストに追加
                        this.virtualObjects.push(newVirtualObj);

                        // xmlTADに追加
                        this.addVirtualObjectToXml(newVirtualObj);

                        // 再描画
                        this.renderVirtualObjects();

                        console.log('[VirtualObjectList] 実身複製成功:', realId, '->', e.data.newRealId);
                    }
                }
            };

            window.addEventListener('message', handleMessage);

            window.parent.postMessage({
                type: 'duplicate-real-object',
                realId: realId,
                messageId: messageId
            }, '*');

            console.log('[VirtualObjectList] 実身複製要求:', realId);
        }
    }

    /**
     * 屑実身操作ウィンドウを開く
     */
    openTrashRealObjects() {
        if (window.parent && window.parent !== window && window.parent.pluginManager) {
            try {
                window.parent.pluginManager.launchPlugin('trash-real-objects', null);
                console.log('[VirtualObjectList] 屑実身操作ウィンドウ起動');
            } catch (error) {
                console.error('[VirtualObjectList] 屑実身操作ウィンドウ起動エラー:', error);
            }
        }
    }

    /**
     * 選択中の仮身が指し示す実身をデフォルトアプリで開く
     */
    openRealObjectWithDefaultApp() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        const applist = selectedVirtualObject.applist;
        if (!applist || typeof applist !== 'object') {
            console.warn('[VirtualObjectList] applistが存在しません');
            return;
        }

        // defaultOpen=trueのプラグインを探す
        let defaultPluginId = null;
        for (const [pluginId, config] of Object.entries(applist)) {
            if (config.defaultOpen === true) {
                defaultPluginId = pluginId;
                break;
            }
        }

        if (!defaultPluginId) {
            // defaultOpen=trueがない場合は最初のプラグインを使用
            defaultPluginId = Object.keys(applist)[0];
        }

        if (!defaultPluginId) {
            console.warn('[VirtualObjectList] 開くためのプラグインが見つかりません');
            return;
        }

        // 実身を開く
        this.executeVirtualObjectWithPlugin(defaultPluginId);

        // 開いた実身を追跡
        const realId = selectedVirtualObject.link_id;
        // windowIdは親ウィンドウから通知される想定
        console.log('[VirtualObjectList] 実身を開く:', realId, 'with', defaultPluginId);
    }

    /**
     * 選択中の仮身が指し示す開いている実身を閉じる
     */
    closeRealObject() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        const realId = selectedVirtualObject.link_id;
        const windowId = this.openedRealObjects.get(realId);

        if (!windowId) {
            console.warn('[VirtualObjectList] 実身が開いていません:', realId);
            return;
        }

        // 親ウィンドウにウィンドウを閉じるよう要求
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'close-window',
                windowId: windowId
            }, '*');

            console.log('[VirtualObjectList] ウィンドウを閉じる要求:', windowId);
        }

        // 追跡からの削除はwindow-closedメッセージで行う
    }

    /**
     * ウィンドウが閉じたことを処理
     */
    handleWindowClosed(windowId, fileData) {
        console.log('[VirtualObjectList] ウィンドウクローズ通知:', windowId, fileData);

        // fileDataから実身IDを取得
        if (fileData && fileData.realId) {
            const realId = fileData.realId;

            // openedRealObjectsから削除
            if (this.openedRealObjects.has(realId)) {
                this.openedRealObjects.delete(realId);
                console.log('[VirtualObjectList] 実身の追跡を削除:', realId);
            }
        }

        // windowIdで検索して削除
        for (const [realId, wId] of this.openedRealObjects.entries()) {
            if (wId === windowId) {
                this.openedRealObjects.delete(realId);
                console.log('[VirtualObjectList] windowIdから実身の追跡を削除:', realId, windowId);
                break;
            }
        }
    }

    /**
     * 仮身属性変更ダイアログを表示
     */
    async changeVirtualObjectAttributes() {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        const vobj = selectedVirtualObject;

        // 現在の属性値を取得
        const currentAttrs = {
            pictdisp: vobj.pictdisp !== 'false',
            namedisp: vobj.namedisp !== 'false',
            roledisp: vobj.roledisp !== 'false',
            typedisp: vobj.typedisp !== 'false',
            updatedisp: vobj.updatedisp !== 'false',
            framedisp: vobj.framedisp !== 'false',
            frcol: vobj.frcol || '#000000',
            chcol: vobj.chcol || '#000000',
            tbcol: vobj.tbcol || '#ffffff',
            bgcol: vobj.bgcol || '#ffffff',
            autoopen: vobj.autoopen === 'true',
            chsz: parseInt(vobj.chsz) || 14  // BTRONのデフォルト文字サイズは14
        };

        console.log('[VirtualObjectList] 仮身属性変更ダイアログ - 現在のchsz:', vobj.chsz, '→', currentAttrs.chsz);

        // 文字サイズの倍率を計算
        const baseFontSize = 14;  // BTRONの標準文字サイズ
        const ratio = currentAttrs.chsz / baseFontSize;
        let selectedRatio = '標準';
        const ratioMap = {
            '1/2倍': 0.5,
            '3/4倍': 0.75,
            '標準': 1.0,
            '3/2倍': 1.5,
            '2倍': 2.0,
            '3倍': 3.0,
            '4倍': 4.0
        };

        for (const [label, value] of Object.entries(ratioMap)) {
            if (Math.abs(ratio - value) < 0.01) {
                selectedRatio = label;
                break;
            }
        }

        // 親ウィンドウにダイアログ表示を要求
        if (window.parent && window.parent !== window) {
            const messageId = `change-vobj-attrs-${Date.now()}-${Math.random()}`;

            const handleMessage = (e) => {
                if (e.data && e.data.type === 'virtual-object-attributes-changed' && e.data.messageId === messageId) {
                    window.removeEventListener('message', handleMessage);

                    if (e.data.success && e.data.attributes) {
                        this.applyVirtualObjectAttributes(e.data.attributes);
                    }
                }
            };

            window.addEventListener('message', handleMessage);

            window.parent.postMessage({
                type: 'change-virtual-object-attributes',
                virtualObject: vobj,
                currentAttributes: currentAttrs,
                selectedRatio: selectedRatio,
                messageId: messageId
            }, '*');

            console.log('[VirtualObjectList] 仮身属性変更ダイアログ要求');
        }
    }

    /**
     * 仮身に属性を適用
     */
    applyVirtualObjectAttributes(attrs) {
        const selectedVirtualObject = this.getSelectedVirtualObject();
        if (!selectedVirtualObject) return;

        const vobj = selectedVirtualObject;

        // 変更があったかどうかを追跡
        let hasChanges = false;
        let pictdispChanged = false;
        let chszChanged = false;

        // 表示項目の設定（値が実際に変更された場合のみ）
        if (attrs.pictdisp !== undefined) {
            const oldValue = vobj.pictdisp;
            const newValue = attrs.pictdisp ? 'true' : 'false';
            if (oldValue !== newValue) {
                vobj.pictdisp = newValue;
                pictdispChanged = true;
                hasChanges = true;
                console.log('[VirtualObjectList] pictdisp変更:', oldValue, '->', newValue);
            }
        }
        if (attrs.namedisp !== undefined) {
            const oldValue = vobj.namedisp;
            const newValue = attrs.namedisp ? 'true' : 'false';
            if (oldValue !== newValue) {
                vobj.namedisp = newValue;
                hasChanges = true;
                console.log('[VirtualObjectList] namedisp変更:', oldValue, '->', newValue);
            }
        }
        if (attrs.roledisp !== undefined) {
            const oldValue = vobj.roledisp;
            const newValue = attrs.roledisp ? 'true' : 'false';
            if (oldValue !== newValue) {
                vobj.roledisp = newValue;
                hasChanges = true;
                console.log('[VirtualObjectList] roledisp変更:', oldValue, '->', newValue);
            }
        }
        if (attrs.typedisp !== undefined) {
            const oldValue = vobj.typedisp;
            const newValue = attrs.typedisp ? 'true' : 'false';
            if (oldValue !== newValue) {
                vobj.typedisp = newValue;
                hasChanges = true;
                console.log('[VirtualObjectList] typedisp変更:', oldValue, '->', newValue);
            }
        }
        if (attrs.updatedisp !== undefined) {
            const oldValue = vobj.updatedisp;
            const newValue = attrs.updatedisp ? 'true' : 'false';
            if (oldValue !== newValue) {
                vobj.updatedisp = newValue;
                hasChanges = true;
                console.log('[VirtualObjectList] updatedisp変更:', oldValue, '->', newValue);
            }
        }
        if (attrs.framedisp !== undefined) {
            const oldValue = vobj.framedisp;
            const newValue = attrs.framedisp ? 'true' : 'false';
            if (oldValue !== newValue) {
                vobj.framedisp = newValue;
                hasChanges = true;
                console.log('[VirtualObjectList] framedisp変更:', oldValue, '->', newValue);
            }
        }

        // 色の設定（値が実際に変更された場合のみ）
        const colorRegex = /^#[0-9A-Fa-f]{6}$/;
        if (attrs.frcol && colorRegex.test(attrs.frcol) && vobj.frcol !== attrs.frcol) {
            console.log('[VirtualObjectList] frcol変更:', vobj.frcol, '->', attrs.frcol);
            vobj.frcol = attrs.frcol;
            hasChanges = true;
        }
        if (attrs.chcol && colorRegex.test(attrs.chcol) && vobj.chcol !== attrs.chcol) {
            console.log('[VirtualObjectList] chcol変更:', vobj.chcol, '->', attrs.chcol);
            vobj.chcol = attrs.chcol;
            hasChanges = true;
        }
        if (attrs.tbcol && colorRegex.test(attrs.tbcol) && vobj.tbcol !== attrs.tbcol) {
            console.log('[VirtualObjectList] tbcol変更:', vobj.tbcol, '->', attrs.tbcol);
            vobj.tbcol = attrs.tbcol;
            hasChanges = true;
        }
        if (attrs.bgcol && colorRegex.test(attrs.bgcol) && vobj.bgcol !== attrs.bgcol) {
            console.log('[VirtualObjectList] bgcol変更:', vobj.bgcol, '->', attrs.bgcol);
            vobj.bgcol = attrs.bgcol;
            hasChanges = true;
        }

        // 文字サイズの設定（値が実際に変更された場合のみ）
        if (attrs.chsz !== undefined) {
            const oldChsz = parseInt(vobj.chsz) || 14;
            const newChsz = parseInt(attrs.chsz);

            // 値が実際に変更された場合のみ処理
            if (oldChsz !== newChsz) {
                vobj.chsz = newChsz.toString();
                chszChanged = true;
                hasChanges = true;

                // DOMから実際の仮身要素を取得し、コンテンツエリアの有無で開閉状態を判定
                const vobjElement = document.querySelector(`.virtual-object[data-link-name="${vobj.link_name}"]`);
                const hasContentArea = vobjElement ?
                    (vobjElement.querySelector('.virtual-object-content-area') !== null ||
                     vobjElement.querySelector('.virtual-object-content-iframe') !== null) : false;

                // 現在のサイズを取得
                const vobjHeight = vobj.vobjbottom - vobj.vobjtop;
                const vobjWidth = vobj.vobjright - vobj.vobjleft;

                console.log('[VirtualObjectList] chsz変更:', {
                    oldChsz,
                    newChsz,
                    vobjHeight,
                    hasContentArea
                });

                if (!hasContentArea) {
                    // 閉じた仮身の場合、高さを新しいchszに合わせて調整
                    // chszはポイント（pt）なのでピクセル（px）に変換
                    const lineHeight = 1.2;
                    const newChszPx = window.convertPtToPx(newChsz);
                    const textHeight = Math.ceil(newChszPx * lineHeight);
                    const newHeight = textHeight + 8;
                    vobj.vobjbottom = vobj.vobjtop + newHeight;
                    console.log('[VirtualObjectList] 閉じた仮身の高さを調整:', vobjHeight, '->', newHeight, `(${newChsz}pt = ${newChszPx}px)`);
                } else {
                    // 開いた仮身の場合、chszに比例して高さを調整
                    const lineHeight = 1.2;
                    const newChszPx = window.convertPtToPx(newChsz);
                    const textHeight = Math.ceil(newChszPx * lineHeight);
                    const newMinOpenHeight = textHeight + 30;
                    const heightRatio = newChsz / oldChsz;
                    const adjustedHeight = Math.max(newMinOpenHeight, Math.round(vobjHeight * heightRatio));
                    vobj.vobjbottom = vobj.vobjtop + adjustedHeight;
                    console.log('[VirtualObjectList] 開いた仮身の高さを比例調整:', vobjHeight, '->', adjustedHeight, 'ratio:', heightRatio);
                }

                // 幅も文字サイズに応じて調整(最小幅を確保)
                const newChszPx = window.convertPtToPx(newChsz);
                const minWidth = Math.max(50, newChszPx * 6); // chszPxの6倍を最小幅とする
                if (vobjWidth < minWidth) {
                    vobj.vobjright = vobj.vobjleft + minWidth;
                    console.log('[VirtualObjectList] 最小幅を確保:', vobjWidth, '->', minWidth);
                }
            } else {
                console.log('[VirtualObjectList] chszは変更なし:', oldChsz);
            }
        }

        // pictdisp変更時の高さ調整（chszが変更されていない場合のみ）
        if (pictdispChanged && !chszChanged) {
            const vobjElement = document.querySelector(`.virtual-object[data-link-name="${vobj.link_name}"]`);
            const hasContentArea = vobjElement ?
                (vobjElement.querySelector('.virtual-object-content-area') !== null ||
                 vobjElement.querySelector('.virtual-object-content-iframe') !== null) : false;

            if (!hasContentArea) {
                // 閉じた仮身の場合、アイコン表示/非表示に関わらず高さは一定
                // chszはポイント（pt）なのでピクセル（px）に変換
                const currentHeight = vobj.vobjbottom - vobj.vobjtop;
                const chsz = parseInt(vobj.chsz) || 14;
                const lineHeight = 1.2;
                const chszPx = window.convertPtToPx(chsz);
                const textHeight = Math.ceil(chszPx * lineHeight);
                const newHeight = textHeight + 8;

                // 高さが既に正しい場合はスキップ
                if (currentHeight !== newHeight) {
                    vobj.vobjbottom = vobj.vobjtop + newHeight;
                    console.log('[VirtualObjectList] pictdisp変更による高さ調整:', currentHeight, '->', newHeight);
                }
            }
        }

        // 自動起動の設定（値が実際に変更された場合のみ）
        if (attrs.autoopen !== undefined) {
            const oldValue = vobj.autoopen;
            const newValue = attrs.autoopen ? 'true' : 'false';
            if (oldValue !== newValue) {
                vobj.autoopen = newValue;
                hasChanges = true;
                console.log('[VirtualObjectList] autoopen変更:', oldValue, '->', newValue);
            }
        }

        // 変更がない場合は早期リターン
        if (!hasChanges) {
            console.log('[VirtualObjectList] 属性に変更がないため処理をスキップ');
            return;
        }

        // xmlTADを更新
        this.updateVirtualObjectInXml(vobj);

        // openedプロパティをクリア（高さベースの判定を使用するため）
        delete vobj.opened;

        // 開いた仮身の場合の処理
        const vobjElement = document.querySelector(`.virtual-object[data-link-id="${vobj.link_id}"]`);
        const iframe = vobjElement ? vobjElement.querySelector('.virtual-object-content-iframe') : null;

        if (vobjElement && iframe) {
            console.log('[VirtualObjectList] 開いた仮身の属性を更新:', vobj.link_name);

            // 背景色のみの変更の場合は、iframeに直接通知して再描画を回避
            const bgcolChanged = attrs.bgcol !== undefined;
            const onlyBgcolChanged = bgcolChanged &&
                Object.keys(attrs).filter(key => attrs[key] !== undefined).length === 1;

            if (onlyBgcolChanged) {
                // 背景色のみ変更の場合、iframeに通知
                if (iframe.contentWindow) {
                    iframe.contentWindow.postMessage({
                        type: 'update-background-color',
                        bgcol: vobj.bgcol
                    }, '*');
                    console.log('[VirtualObjectList] 開いた仮身のiframeに背景色変更を通知:', vobj.bgcol);
                }
            } else {
                // その他の属性変更がある場合は、再描画
                this.renderVirtualObjects();
            }
        } else {
            // 開いていない仮身の場合は通常の再描画
            this.renderVirtualObjects();
        }

        console.log('[VirtualObjectList] 仮身属性を適用:', attrs);
    }

    /**
     * 整頓ダイアログを表示
     */
    async showArrangeDialog() {
        if (this.selectedVirtualObjects.size === 0) {
            console.warn('[VirtualObjectList] 選択中の仮身がありません');
            return;
        }

        const selectedCount = this.selectedVirtualObjects.size;
        const isMultiple = selectedCount > 1;

        // ダイアログのHTML要素を作成（3段組レイアウト、縦並び、圧縮版）
        const dialogHtml = `<div class="arrange-dialog"><div style="margin:0;padding:0;line-height:0.6">選択: ${selectedCount}個</div><div style="display:flex;gap:0;margin:0;padding:0">
                <!-- 左列 -->
                <div style="flex: 1; padding-right: 2px; line-height: 0.8;">
                    <!-- 横 -->
                    <div style="margin: 0;">
                        <div style="margin: 0; display: flex; align-items: center;">
                            <span style="font-weight: bold; margin-right: 2px; min-width: 28px;">横</span>
                            <label style="margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="horizontal" value="left" ${!isMultiple ? 'disabled' : ''}>左揃え
                            </label>
                        </div>
                        <div style="margin: 0; padding-left: 30px;">
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="horizontal" value="right" ${!isMultiple ? 'disabled' : ''}>右揃え
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="horizontal" value="none" checked>なし
                            </label>
                        </div>
                    </div>

                    <!-- 縦 -->
                    <div style="margin: 0;">
                        <div style="margin: 0; display: flex; align-items: center;">
                            <span style="font-weight: bold; margin-right: 2px; min-width: 28px;">縦</span>
                            <label style="margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="vertical" value="compact" ${!isMultiple ? 'disabled' : ''}>詰める
                            </label>
                        </div>
                        <div style="margin: 0; padding-left: 30px;">
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="vertical" value="align" ${!isMultiple ? 'disabled' : ''}>先頭
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="vertical" value="none" checked>なし
                            </label>
                        </div>
                    </div>

                    <!-- 段組数 -->
                    <div style="margin: 0;">
                        <div style="margin: 0; display: flex; align-items: center;">
                            <span style="font-weight: bold; margin-right: 2px; min-width: 28px;">段組数</span>
                            <input type="number" id="columnCount" min="1" value="1" style="width: 35px; font-size: 9px;" ${!isMultiple ? 'disabled' : ''}>
                        </div>
                    </div>
                </div>

                <!-- 中列 -->
                <div style="flex: 1; padding-right: 2px; line-height: 0.8;">
                    <!-- 段組 -->
                    <div style="margin: 0;">
                        <div style="margin: 0; display: flex; align-items: center;">
                            <span style="font-weight: bold; margin-right: 2px; min-width: 28px;">段組</span>
                            <label style="margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="column" value="single" ${!isMultiple ? 'disabled' : ''}>1段
                            </label>
                        </div>
                        <div style="margin: 0; padding-left: 30px;">
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="column" value="multi-horizontal" ${!isMultiple ? 'disabled' : ''}>左右
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="column" value="multi-vertical" ${!isMultiple ? 'disabled' : ''}>上下
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="column" value="none" checked>なし
                            </label>
                        </div>
                    </div>

                    <!-- 長さ -->
                    <div style="margin: 0;">
                        <div style="margin: 0; display: flex; align-items: center;">
                            <span style="font-weight: bold; margin-right: 2px; min-width: 28px;">長さ</span>
                            <label style="margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="length" value="first">先頭
                            </label>
                        </div>
                        <div style="margin: 0; padding-left: 30px;">
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="length" value="full">全体
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="length" value="icon-name">図名
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="length" value="with-relation">続柄
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="length" value="without-date">日付なし
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="length" value="none" checked>なし
                            </label>
                        </div>
                    </div>
                </div>

                <!-- 右列 -->
                <div style="flex: 1; line-height: 0.8;">
                    <!-- 整列順 -->
                    <div style="margin: 0;">
                        <div style="margin: 0; display: flex; align-items: center;">
                            <span style="font-weight: bold; margin-right: 2px; min-width: 34px;">整列順</span>
                            <label style="margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="sortBy" value="name" ${!isMultiple ? 'disabled' : ''}>名前
                            </label>
                        </div>
                        <div style="margin: 0; padding-left: 36px;">
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="sortBy" value="created" ${!isMultiple ? 'disabled' : ''}>作成日
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="sortBy" value="updated" ${!isMultiple ? 'disabled' : ''}>更新日
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="sortBy" value="size" ${!isMultiple ? 'disabled' : ''}>サイズ
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="sortBy" value="none" checked>なし
                            </label>
                        </div>
                    </div>

                    <!-- 順序 -->
                    <div style="margin: 0;">
                        <div style="margin: 0; display: flex; align-items: center;">
                            <span style="font-weight: bold; margin-right: 2px; min-width: 34px;">順序</span>
                            <label style="margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="sortOrder" value="asc" ${!isMultiple ? 'disabled' : ''}>昇順
                            </label>
                        </div>
                        <div style="margin: 0; padding-left: 36px;">
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="sortOrder" value="desc" ${!isMultiple ? 'disabled' : ''}>降順
                            </label>
                            <label style="display: block; margin: 0; padding: 0; line-height: 0.8;">
                                <input type="radio" name="sortOrder" value="none" checked>なし
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            </div>
        `;

        return new Promise((resolve) => {
            const messageId = `arrange_${Date.now()}_${Math.random()}`;

            this.dialogCallbacks[messageId] = (result) => {
                if (result.button === 'ok') {
                    // フォームの値を取得
                    const horizontal = (result.radios && result.radios.horizontal) || 'none';
                    const vertical = (result.radios && result.radios.vertical) || 'none';
                    const column = (result.radios && result.radios.column) || 'none';
                    const length = (result.radios && result.radios.length) || 'none';
                    const sortBy = (result.radios && result.radios.sortBy) || 'none';
                    const sortOrder = (result.radios && result.radios.sortOrder) || 'none';
                    const columnCount = parseInt((result.inputs && result.inputs.columnCount) || '1') || 1;

                    console.log('[VirtualObjectList] 整頓設定:', {
                        horizontal, vertical, column, columnCount,
                        length, sortBy, sortOrder
                    });

                    // 整頓処理を実行
                    this.arrangeVirtualObjects({
                        horizontal, vertical, column, columnCount,
                        length, sortBy, sortOrder
                    });
                }
                resolve(result);
            };

            // 親ウィンドウにダイアログ表示を要求
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'show-custom-dialog',
                    messageId: messageId,
                    title: '整頓',
                    dialogHtml: dialogHtml,
                    buttons: [
                        { label: 'キャンセル', value: 'cancel' },
                        { label: 'OK', value: 'ok' }
                    ],
                    defaultButton: 1,
                    inputs: {
                        text: 'columnCount'
                    },
                    radios: {
                        horizontal: 'horizontal',
                        vertical: 'vertical',
                        column: 'column',
                        length: 'length',
                        sortBy: 'sortBy',
                        sortOrder: 'sortOrder'
                    }
                }, '*');
            }

            console.log('[VirtualObjectList] 整頓ダイアログ要求');
        });
    }

    /**
     * 仮身を整頓する
     */
    arrangeVirtualObjects(options) {
        const selectedObjects = Array.from(this.selectedVirtualObjects);
        if (selectedObjects.length === 0) return;

        console.log('[VirtualObjectList] 整頓開始:', options, '選択数:', selectedObjects.length);

        // 先頭の仮身（最初に選択されたもの）
        const firstObj = selectedObjects[0];

        // ソート処理（複数選択時のみ）
        if (selectedObjects.length > 1 && options.sortBy !== 'none') {
            this.sortVirtualObjects(selectedObjects, options.sortBy, options.sortOrder);
        }

        // 長さ調整
        if (options.length !== 'none') {
            this.adjustVirtualObjectLength(selectedObjects, options.length, firstObj);
        }

        // 段組・配置処理（複数選択時のみ）
        if (selectedObjects.length > 1) {
            if (options.column === 'single') {
                // 1段組: 上から下に縦に並べる
                this.arrangeSingleColumn(selectedObjects, firstObj, options);
            } else if (options.column === 'multi-horizontal') {
                // 複数段組（左右配置）
                this.arrangeMultiColumnHorizontal(selectedObjects, firstObj, options);
            } else if (options.column === 'multi-vertical') {
                // 複数段組（上下配置）
                this.arrangeMultiColumnVertical(selectedObjects, firstObj, options);
            } else {
                // 段組指定なしの場合、横・縦の調整のみ
                this.adjustHorizontalVertical(selectedObjects, firstObj, options);
            }
        }

        // 再描画
        this.renderVirtualObjects();
        console.log('[VirtualObjectList] 整頓完了');
    }

    /**
     * 仮身をソート
     */
    sortVirtualObjects(objects, sortBy, sortOrder) {
        objects.sort((a, b) => {
            let compare = 0;

            switch (sortBy) {
                case 'name':
                    compare = (a.link_name || '').localeCompare(b.link_name || '');
                    break;
                case 'created':
                    const aCreated = a.metadata?.makeDate || '';
                    const bCreated = b.metadata?.makeDate || '';
                    compare = aCreated.localeCompare(bCreated);
                    break;
                case 'updated':
                    const aUpdated = a.metadata?.updateDate || '';
                    const bUpdated = b.metadata?.updateDate || '';
                    compare = aUpdated.localeCompare(bUpdated);
                    break;
                case 'size':
                    const aSize = a.metadata?.size || 0;
                    const bSize = b.metadata?.size || 0;
                    compare = aSize - bSize;
                    break;
            }

            // 降順の場合は反転
            if (sortOrder === 'desc') {
                compare = -compare;
            }

            return compare;
        });
    }

    /**
     * 仮身の長さを調整
     */
    adjustVirtualObjectLength(objects, lengthType, firstObj) {
        let targetHeight;

        switch (lengthType) {
            case 'first':
                // 先頭の長さ
                targetHeight = firstObj.vobjbottom - firstObj.vobjtop;
                break;
            case 'full':
                // 全体を表示する長さ（開いた状態の想定）
                targetHeight = 200;
                break;
            case 'icon-name':
                // ピクトグラムと名前のみ
                targetHeight = 33;
                break;
            case 'with-relation':
                // 続柄まで表示
                targetHeight = 50;
                break;
            case 'without-date':
                // 日付のみ表示しない
                targetHeight = 70;
                break;
            default:
                return;
        }

        // 各仮身の高さを調整
        objects.forEach(obj => {
            const currentHeight = obj.vobjbottom - obj.vobjtop;
            const diff = targetHeight - currentHeight;
            obj.vobjbottom += diff;
        });
    }

    /**
     * 1段組配置
     */
    arrangeSingleColumn(objects, firstObj, options) {
        let currentTop = firstObj.vobjtop;
        const spacing = options.vertical === 'compact' ? 5 :
                       (objects.length > 1 ? objects[1].vobjtop - objects[0].vobjbottom : 10);

        objects.forEach(obj => {
            const height = obj.vobjbottom - obj.vobjtop;
            const width = obj.vobjright - obj.vobjleft;

            // 横位置の調整
            if (options.horizontal === 'left') {
                obj.vobjleft = firstObj.vobjleft;
                obj.vobjright = obj.vobjleft + width;
            } else if (options.horizontal === 'right') {
                obj.vobjright = firstObj.vobjright;
                obj.vobjleft = obj.vobjright - width;
            }

            // 縦位置の調整
            obj.vobjtop = currentTop;
            obj.vobjbottom = currentTop + height;

            currentTop = obj.vobjbottom + spacing;
        });
    }

    /**
     * 複数段組配置（左右配置）
     */
    arrangeMultiColumnHorizontal(objects, firstObj, options) {
        const columnCount = options.columnCount || 2;
        const spacing = options.vertical === 'compact' ? 5 : 10;
        const horizontalSpacing = 10;

        let currentRow = 0;
        let currentCol = 0;
        let rowTops = [firstObj.vobjtop];
        let colLefts = [firstObj.vobjleft];

        objects.forEach((obj, index) => {
            const height = obj.vobjbottom - obj.vobjtop;
            const width = obj.vobjright - obj.vobjleft;

            // 列の左位置を計算
            if (currentCol > 0 && !colLefts[currentCol]) {
                const prevObj = objects[index - 1];
                colLefts[currentCol] = prevObj.vobjright + horizontalSpacing;
            }

            // 配置
            obj.vobjleft = colLefts[currentCol] || firstObj.vobjleft;
            obj.vobjright = obj.vobjleft + width;
            obj.vobjtop = rowTops[currentRow];
            obj.vobjbottom = obj.vobjtop + height;

            currentCol++;
            if (currentCol >= columnCount) {
                // 次の行へ
                currentCol = 0;
                currentRow++;
                // 現在の行の最大の高さを計算
                const rowObjects = objects.slice(Math.max(0, index - columnCount + 1), index + 1);
                const maxBottom = Math.max(...rowObjects.map(o => o.vobjbottom));
                rowTops[currentRow] = maxBottom + spacing;
            }
        });
    }

    /**
     * 複数段組配置（上下配置）
     */
    arrangeMultiColumnVertical(objects, firstObj, options) {
        const columnCount = options.columnCount || 2;
        const spacing = options.vertical === 'compact' ? 5 : 10;
        const horizontalSpacing = 10;

        // 全体の縦幅を計算
        const topmost = Math.min(...objects.map(o => o.vobjtop));
        const bottommost = Math.max(...objects.map(o => o.vobjbottom));
        const totalHeight = bottommost - topmost;

        // 各列の要素数を計算
        const itemsPerColumn = Math.ceil(objects.length / columnCount);

        let currentCol = 0;
        let currentRow = 0;
        let colLefts = [firstObj.vobjleft];

        objects.forEach((obj, index) => {
            const height = obj.vobjbottom - obj.vobjtop;
            const width = obj.vobjright - obj.vobjleft;

            currentCol = Math.floor(index / itemsPerColumn);
            currentRow = index % itemsPerColumn;

            // 列の左位置を計算
            if (currentCol > 0 && !colLefts[currentCol]) {
                const prevColIndex = currentCol * itemsPerColumn - 1;
                if (prevColIndex >= 0 && prevColIndex < objects.length) {
                    const prevObj = objects[prevColIndex];
                    colLefts[currentCol] = prevObj.vobjright + horizontalSpacing;
                }
            }

            // 配置
            obj.vobjleft = colLefts[currentCol] || firstObj.vobjleft;
            obj.vobjright = obj.vobjleft + width;

            if (currentRow === 0) {
                obj.vobjtop = firstObj.vobjtop;
            } else {
                const prevObj = objects[index - 1];
                obj.vobjtop = prevObj.vobjbottom + spacing;
            }
            obj.vobjbottom = obj.vobjtop + height;
        });
    }

    /**
     * 横・縦のみ調整（段組指定なし）
     */
    adjustHorizontalVertical(objects, firstObj, options) {
        if (options.horizontal === 'none' && options.vertical === 'none') {
            return;
        }

        // Y座標でソート（上から順に処理）
        const sortedObjects = [...objects].sort((a, b) => a.vobjtop - b.vobjtop);

        let prevObj = null;
        sortedObjects.forEach(obj => {
            const width = obj.vobjright - obj.vobjleft;
            const height = obj.vobjbottom - obj.vobjtop;

            // 横位置の調整
            if (options.horizontal === 'left') {
                obj.vobjleft = firstObj.vobjleft;
                obj.vobjright = obj.vobjleft + width;
            } else if (options.horizontal === 'right') {
                obj.vobjright = firstObj.vobjright;
                obj.vobjleft = obj.vobjright - width;
            }

            // 縦位置の調整
            if (prevObj && options.vertical !== 'none') {
                let spacing;
                if (options.vertical === 'compact') {
                    spacing = 5;
                } else if (options.vertical === 'align') {
                    // 先頭の間隔
                    spacing = objects.length > 1 ?
                             objects[1].vobjtop - objects[0].vobjbottom : 10;
                }
                obj.vobjtop = prevObj.vobjbottom + spacing;
                obj.vobjbottom = obj.vobjtop + height;
            }

            prevObj = obj;
        });
    }

    /**
     * xmlTADに仮身を追加
     * @param {Object} virtualObj - 追加する仮身オブジェクト
     */
    addVirtualObjectToXml(virtualObj) {
        if (!this.xmlData) {
            console.warn('[VirtualObjectList] xmlDataがありません');
            return;
        }

        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(this.xmlData, 'text/xml');

            // 新しい<link>要素を作成
            const linkElement = xmlDoc.createElement('link');
            linkElement.setAttribute('id', virtualObj.link_id);
            linkElement.setAttribute('vobjleft', virtualObj.vobjleft.toString());
            linkElement.setAttribute('vobjtop', virtualObj.vobjtop.toString());
            linkElement.setAttribute('vobjright', virtualObj.vobjright.toString());
            linkElement.setAttribute('vobjbottom', virtualObj.vobjbottom.toString());
            linkElement.setAttribute('height', (virtualObj.height_px || 30).toString());
            linkElement.setAttribute('chsz', (virtualObj.chsz || 14).toString());
            linkElement.setAttribute('frcol', virtualObj.frcol || '#000000');
            linkElement.setAttribute('chcol', virtualObj.chcol || '#000000');
            linkElement.setAttribute('tbcol', virtualObj.tbcol || '#ffffff');
            linkElement.setAttribute('bgcol', virtualObj.bgcol || '#ffffff');
            linkElement.setAttribute('dlen', (virtualObj.dlen || 0).toString());
            linkElement.textContent = virtualObj.link_name || '';

            // <figure>要素を探して、その中に追加
            const figureElement = xmlDoc.getElementsByTagName('figure')[0];
            if (figureElement) {
                figureElement.appendChild(linkElement);
                console.log('[VirtualObjectList] <figure>要素内に仮身を追加');
            } else {
                // <figure>がない場合はルート要素に追加
                const rootElement = xmlDoc.documentElement;
                rootElement.appendChild(linkElement);
                console.log('[VirtualObjectList] <figure>がないためルート要素に仮身を追加');
            }

            // XMLを文字列に戻す
            const serializer = new XMLSerializer();
            this.xmlData = serializer.serializeToString(xmlDoc);

            console.log('[VirtualObjectList] xmlTADに仮身を追加:', virtualObj.link_id);

            // 自動保存
            this.notifyXmlDataChanged();

        } catch (error) {
            console.error('[VirtualObjectList] xmlTAD追加エラー:', error);
        }
    }

    /**
     * xmlTADから仮身を削除
     * @param {Object} virtualObj - 削除する仮身オブジェクト
     */
    removeVirtualObjectFromXml(virtualObj) {
        if (!this.xmlData) {
            console.warn('[VirtualObjectList] xmlDataがありません');
            return;
        }

        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(this.xmlData, 'text/xml');

            // 削除する<link>要素を探す
            const linkElements = xmlDoc.getElementsByTagName('link');
            for (let i = linkElements.length - 1; i >= 0; i--) {
                const linkElement = linkElements[i];
                if (linkElement.getAttribute('id') === virtualObj.link_id) {
                    linkElement.parentNode.removeChild(linkElement);
                    console.log('[VirtualObjectList] <link>要素を削除:', virtualObj.link_id);
                    break;
                }
            }

            // XMLを文字列に戻す
            const serializer = new XMLSerializer();
            this.xmlData = serializer.serializeToString(xmlDoc);

            console.log('[VirtualObjectList] xmlTADから仮身を削除:', virtualObj.link_id);

            // 自動保存
            this.notifyXmlDataChanged();

        } catch (error) {
            console.error('[VirtualObjectList] xmlTAD削除エラー:', error);
        }
    }

    /**
     * xmlTAD内の仮身を更新
     * @param {Object} virtualObj - 更新する仮身オブジェクト
     */
    updateVirtualObjectInXml(virtualObj) {
        if (!this.xmlData) {
            console.warn('[VirtualObjectList] xmlDataがありません');
            return;
        }

        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(this.xmlData, 'text/xml');

            // 更新する<link>要素を探す
            const linkElements = xmlDoc.getElementsByTagName('link');
            for (let i = 0; i < linkElements.length; i++) {
                const linkElement = linkElements[i];
                if (linkElement.getAttribute('id') === virtualObj.link_id) {
                    // 属性を更新
                    linkElement.setAttribute('vobjleft', virtualObj.vobjleft.toString());
                    linkElement.setAttribute('vobjtop', virtualObj.vobjtop.toString());
                    linkElement.setAttribute('vobjright', virtualObj.vobjright.toString());
                    linkElement.setAttribute('vobjbottom', virtualObj.vobjbottom.toString());
                    linkElement.setAttribute('height', (virtualObj.height_px || 30).toString());
                    linkElement.setAttribute('chsz', (virtualObj.chsz || 14).toString());
                    linkElement.setAttribute('frcol', virtualObj.frcol || '#000000');
                    linkElement.setAttribute('chcol', virtualObj.chcol || '#000000');
                    linkElement.setAttribute('tbcol', virtualObj.tbcol || '#ffffff');
                    linkElement.setAttribute('bgcol', virtualObj.bgcol || '#ffffff');
                    linkElement.setAttribute('dlen', (virtualObj.dlen || 0).toString());

                    // 表示属性（あれば設定）
                    if (virtualObj.pictdisp !== undefined) {
                        linkElement.setAttribute('pictdisp', virtualObj.pictdisp.toString());
                    }
                    if (virtualObj.namedisp !== undefined) {
                        linkElement.setAttribute('namedisp', virtualObj.namedisp.toString());
                    }
                    if (virtualObj.roledisp !== undefined) {
                        linkElement.setAttribute('roledisp', virtualObj.roledisp.toString());
                    }
                    if (virtualObj.typedisp !== undefined) {
                        linkElement.setAttribute('typedisp', virtualObj.typedisp.toString());
                    }
                    if (virtualObj.updatedisp !== undefined) {
                        linkElement.setAttribute('updatedisp', virtualObj.updatedisp.toString());
                    }
                    if (virtualObj.framedisp !== undefined) {
                        linkElement.setAttribute('framedisp', virtualObj.framedisp.toString());
                    }
                    if (virtualObj.autoopen !== undefined) {
                        linkElement.setAttribute('autoopen', virtualObj.autoopen.toString());
                    }

                    linkElement.textContent = virtualObj.link_name || '';
                    console.log('[VirtualObjectList] <link>要素を更新:', virtualObj.link_id);
                    
                    // 元の位置情報を更新（次回の移動時に正しく識別できるように）
                    virtualObj.originalLeft = virtualObj.vobjleft;
                    virtualObj.originalTop = virtualObj.vobjtop;
                    virtualObj.originalRight = virtualObj.vobjright;
                    virtualObj.originalBottom = virtualObj.vobjbottom;
                    
                    break;
                }
            }

            // XMLを文字列に戻す
            const serializer = new XMLSerializer();
            this.xmlData = serializer.serializeToString(xmlDoc);

            console.log('[VirtualObjectList] xmlTADの仮身を更新:', virtualObj.link_id);

            // 自動保存
            this.notifyXmlDataChanged();

        } catch (error) {
            console.error('[VirtualObjectList] xmlTAD更新エラー:', error);
        }
    }

    /**
     * 親ウィンドウに仮身コピーを通知（refCount+1）
     * @param {string} realId - 実身ID
     */
    requestCopyVirtualObject(realId) {
        if (window.parent && window.parent !== window) {
            // link_idの場合、実身IDを抽出（_[recordno].xtad を削除）
            const actualRealId = realId.replace(/_\d+\.xtad$/, '');

            const messageId = `copy-virtual-${Date.now()}-${Math.random()}`;
            window.parent.postMessage({
                type: 'copy-virtual-object',
                realId: actualRealId,
                messageId: messageId
            }, '*');
            console.log('[VirtualObjectList] 仮身コピー要求:', actualRealId, '(元:', realId, ')');
        }
    }

    /**
     * 親ウィンドウに仮身削除を通知（refCount-1）
     * @param {string} realId - 実身ID
     */
    requestDeleteVirtualObject(realId) {
        if (window.parent && window.parent !== window) {
            // link_idの場合、実身IDを抽出（_[recordno].xtad を削除）
            const actualRealId = realId.replace(/_\d+\.xtad$/, '');

            const messageId = `delete-virtual-${Date.now()}-${Math.random()}`;
            window.parent.postMessage({
                type: 'delete-virtual-object',
                realId: actualRealId,
                messageId: messageId
            }, '*');
            console.log('[VirtualObjectList] 仮身削除要求:', actualRealId, '(元:', realId, ')');
        }
    }

    setupContextMenu() {
        // 右クリックメニューを開いた直後かどうかのフラグ
        this.justOpenedContextMenu = false;

        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();

            if (window.parent && window.parent !== window) {
                const rect = window.frameElement.getBoundingClientRect();

                // 右クリックメニューを開いたことを記録
                this.justOpenedContextMenu = true;
                setTimeout(() => {
                    this.justOpenedContextMenu = false;
                }, 100);

                window.parent.postMessage({
                    type: 'context-menu-request',
                    x: rect.left + e.clientX,
                    y: rect.top + e.clientY
                }, '*');
            }
        });

        document.addEventListener('click', () => {
            // 右クリックメニューを開いた直後は無視
            if (this.justOpenedContextMenu) {
                return;
            }

            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'close-context-menu'
                }, '*');
            }
        });
    }

    setupWindowActivation() {
        document.addEventListener('mousedown', () => {
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'activate-window'
                }, '*');
            }

            // キーボードショートカットが動作するようにbodyにフォーカスを設定
            document.body.focus();
        });
    }

    /**
     * キーボードショートカットを設定
     */
    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Ctrl+L: 全画面表示
            if (e.ctrlKey && e.key === 'l') {
                e.preventDefault();
                this.toggleFullscreen();
            }
            // Ctrl+S: 保存
            else if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                this.saveToFile();
            }
            // Ctrl+E: ウィンドウを閉じる
            else if (e.ctrlKey && e.key === 'e') {
                e.preventDefault();
                this.requestCloseWindow();
            }
            // Ctrl+O: 選択中の仮身をdefaultOpenアプリで開く
            else if (e.ctrlKey && e.key === 'o') {
                e.preventDefault();
                this.openRealObjectWithDefaultApp();
            }
            // Delete: 選択中の仮身を削除
            else if (e.key === 'Delete') {
                e.preventDefault();
                this.deleteSelectedVirtualObject();
            }
        });
    }

    /**
     * グローバルマウスイベントハンドラーを設定（ドラッグ用）
     */
    setupGlobalMouseHandlers() {
        // ドラッグ用のmousemoveハンドラ
        const handleDragMouseMove = (e) => {
            if (!this.draggingState.isDragging) return;

            const deltaX = e.clientX - this.draggingState.startX;
            const deltaY = e.clientY - this.draggingState.startY;

            // 5px以上移動したらドラッグとみなす
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                if (!this.draggingState.hasMoved) {
                    console.log('[VirtualObjectList] mousemove: 移動検知 delta:', deltaX, deltaY);
                }
                this.draggingState.hasMoved = true;
            }

            if (this.draggingState.hasMoved && this.draggingState.currentElement) {
                const newLeft = this.draggingState.initialLeft + deltaX;
                const newTop = this.draggingState.initialTop + deltaY;

                this.draggingState.currentElement.style.left = newLeft + 'px';
                this.draggingState.currentElement.style.top = newTop + 'px';
            }
        };

        // スロットル版のmousemoveハンドラ（60FPS制限）
        const throttledDragMouseMove = window.throttleRAF ? window.throttleRAF(handleDragMouseMove) : handleDragMouseMove;

        // document全体でのmousemove
        document.addEventListener('mousemove', throttledDragMouseMove);

        // document全体でのmouseup
        document.addEventListener('mouseup', (e) => {
            console.log('[VirtualObjectList] mouseup検知 isDragging:', this.draggingState.isDragging, 'hasMoved:', this.draggingState.hasMoved, 'button:', e.button);

            // BTRONの仕様: 左右両方押してドラッグ中に、左ボタンを先に離した場合はコピーモード
            if (this.draggingState.isDragging && e.button === 0) {
                // 左ボタンが離された
                // ドラッグ中であれば、dragModeをcopyに変更
                if (this.draggingState.hasMoved) {
                    this.draggingState.dragMode = 'copy';
                    console.log('[VirtualObjectList] 左ボタンをドラッグ中に離した → コピーモードに変更');
                    return; // 右ボタンのmouseupを待つ
                }
            }

            if (this.draggingState.isDragging) {
                if (this.draggingState.hasMoved) {
                    // 移動があった場合は位置を確定
                    console.log('[VirtualObjectList] mouseup: ドラッグ完了、finishDrag()呼び出し');
                    this.finishDrag();
                } else {
                    // 移動がなかった場合は状態をリセット
                    console.log('[VirtualObjectList] mouseup: 移動なし、状態リセット');
                    this.draggingState.isDragging = false;
                    this.draggingState.currentObject = null;
                    this.draggingState.currentElement = null;
                }
            }
        });

        // 親ウィンドウからのmouseupメッセージを受信
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'parent-mouseup') {
                // HTML5 Drag&Dropを使う場合、dragendで処理するため何もしない
                console.log('[VirtualObjectList] 親ウィンドウのmouseup検知 isDragging:', this.draggingState.isDragging, 'hasMoved:', this.draggingState.hasMoved);
            }
        });
    }

    /**
     * ドラッグを終了する処理
     */
    finishDrag() {
        if (!this.draggingState.isDragging) return;

        console.log('[VirtualObjectList] ドラッグ終了:', this.draggingState.currentObject?.link_name, 'モード:', this.draggingState.dragMode);

        if (this.draggingState.hasMoved && this.draggingState.currentObject && this.draggingState.currentElement) {
            const obj = this.draggingState.currentObject;
            const vobjElement = this.draggingState.currentElement;

            // ドラッグで移動した場合
            let newLeft, newTop;

            // dropイベントで座標が保存されている場合はそれを使用
            if (this.draggingState.dropClientX !== undefined && this.draggingState.dropClientY !== undefined) {
                const deltaX = this.draggingState.dropClientX - this.draggingState.startX;
                const deltaY = this.draggingState.dropClientY - this.draggingState.startY;
                newLeft = this.draggingState.initialLeft + deltaX;
                newTop = this.draggingState.initialTop + deltaY;
                console.log('[VirtualObjectList] dropイベントの座標を使用:',
                    'drop:', this.draggingState.dropClientX, this.draggingState.dropClientY,
                    'delta:', deltaX, deltaY,
                    'new:', newLeft, newTop);
            } else {
                // dragイベントで更新された style.left/top を使用（従来の方法）
                newLeft = parseInt(vobjElement.style.left);
                newTop = parseInt(vobjElement.style.top);
                console.log('[VirtualObjectList] style.left/topを使用:', newLeft, newTop);
            }

            // 元のサイズを保持（obj.widthとobj.height_pxを優先使用）
            const width = obj.width || (obj.vobjright - obj.vobjleft);
            const height = obj.height_px || (obj.vobjbottom - obj.vobjtop);

            if (this.draggingState.dragMode === 'copy') {
                // コピーモード: 元の仮身を元の位置に戻し、新しい仮身を作成
                console.log('[VirtualObjectList] コピーモード: 元の仮身を復元し、新しい仮身を作成');

                // 元の仮身要素を元の位置に戻す
                vobjElement.style.left = this.draggingState.initialLeft + 'px';
                vobjElement.style.top = this.draggingState.initialTop + 'px';

                // 新しい仮身オブジェクトを作成
                const newObj = {
                    link_id: obj.link_id,
                    link_name: obj.link_name,
                    vobjleft: newLeft,
                    vobjtop: newTop,
                    vobjright: newLeft + width,
                    vobjbottom: newTop + height,
                    width: width,
                    height_px: height,
                    chsz: obj.chsz || 14,
                    frcol: obj.frcol || '#000000',
                    chcol: obj.chcol || '#000000',
                    tbcol: obj.tbcol || '#ffffff',
                    bgcol: obj.bgcol || '#ffffff',
                    dlen: obj.dlen || 0,
                    applist: obj.applist || {},
                    originalLeft: newLeft,
                    originalTop: newTop,
                    originalRight: newLeft + width,
                    originalBottom: newTop + height
                };

                // 仮身リストに追加
                this.virtualObjects.push(newObj);

                // xmlTADに追加
                this.addVirtualObjectToXml(newObj);

                // 再描画
                this.renderVirtualObjects();

                // refCountを増やす
                this.requestCopyVirtualObject(obj.link_id);

            } else {
                // 移動モード: 位置を更新
                obj.vobjleft = newLeft;
                obj.vobjtop = newTop;
                obj.vobjright = newLeft + width;
                obj.vobjbottom = newTop + height;

                console.log('[VirtualObjectList] 移動モード: ドラッグ終了:', obj.link_name, {
                    left: obj.vobjleft,
                    top: obj.vobjtop,
                    right: obj.vobjright,
                    bottom: obj.vobjbottom,
                    width: width,
                    height: height,
                    originalLeft: obj.originalLeft,
                    originalTop: obj.originalTop,
                    originalRight: obj.originalRight,
                    originalBottom: obj.originalBottom
                });

                // xmlTADを更新
                console.log('[VirtualObjectList] updateVirtualObjectPosition呼び出し前:', obj.link_id, '元の位置:', obj.originalLeft, obj.originalTop);
                this.updateVirtualObjectPosition(obj);
            }

            // キャンバスサイズを更新
            this.updateCanvasSize();
        }

        // ドラッグ状態をリセット（dragModeも忘れずに）
        this.draggingState.isDragging = false;
        this.draggingState.hasMoved = false;
        this.draggingState.currentObject = null;
        this.draggingState.currentElement = null;
        this.draggingState.dropClientX = undefined;
        this.draggingState.dropClientY = undefined;
        this.draggingState.dragMode = 'move'; // デフォルトに戻す

        // スクロールを再有効化（念のため）
        const pluginContent = document.querySelector('.plugin-content');
        if (pluginContent && pluginContent.style.overflow === 'hidden') {
            pluginContent.style.overflow = 'auto';
            console.log('[VirtualObjectList] finishDrag: スクロールを再有効化');
        }
    }

    /**
     * 全画面表示切り替え
     */
    toggleFullscreen() {
        // 親ウィンドウにメッセージを送信してウィンドウを最大化/元に戻す
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'toggle-maximize'
            }, '*');

            this.isFullscreen = !this.isFullscreen;
            console.log('[VirtualObjectList] 全画面表示:', this.isFullscreen ? 'ON' : 'OFF');

            // 実身管理用セグメントのfullscreenフラグを更新
            if (this.fileId && window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'update-fullscreen-state',
                    fileId: this.fileId,
                    isFullscreen: this.isFullscreen
                }, '*');
                console.log('[VirtualObjectList] 全画面表示状態更新を親ウィンドウに通知:', this.fileId, this.isFullscreen);
            }
        }
    }

    /**
     * 再表示（画面を再描画）
     */
    refresh() {
        this.renderVirtualObjects();
        console.log('[VirtualObjectList] 再表示しました');
    }

    /**
     * 背景色を適用
     */
    applyBackgroundColor() {
        // 開いた仮身の場合はthis.bgcolを優先、それ以外はwindowConfig.backgroundColor
        const bgColor = this.bgcol || (this.fileData && this.fileData.windowConfig && this.fileData.windowConfig.backgroundColor);

        if (bgColor) {
            // DOM要素が生成されるまで待機
            setTimeout(() => {
                // 開いた仮身として表示される場合は、body全体に背景色を適用
                if (this.bgcol) {
                    document.body.style.backgroundColor = bgColor;
                    const pluginContent = document.querySelector('.plugin-content');
                    if (pluginContent) {
                        pluginContent.style.backgroundColor = bgColor;
                    }
                    console.log('[VirtualObjectList] 背景色を適用 (開いた仮身):', bgColor);
                }

                // 通常のウィンドウ表示の場合は、canvasに背景色を適用
                const canvas = document.querySelector('.virtual-canvas');
                if (canvas) {
                    canvas.style.background = bgColor;
                    if (!this.bgcol) {
                        console.log('[VirtualObjectList] 背景色を適用 (ウィンドウ設定):', bgColor);
                    }
                } else if (!this.bgcol) {
                    // 開いた仮身でない場合のみ警告
                    console.warn('[VirtualObjectList] .virtual-canvas 要素が見つかりません');
                }
            }, 100);
        } else {
            console.log('[VirtualObjectList] 背景色が設定されていません');
        }
    }

    /**
     * 背景色変更ダイアログを表示
     */
    async changeBgColor() {
        return new Promise((resolve) => {
            const messageId = `bg_color_${Date.now()}_${Math.random()}`;
            const selectedVirtualObject = this.getSelectedVirtualObject();

            // 現在の背景色を取得
            const currentBgColor = (this.fileData && this.fileData.windowConfig && this.fileData.windowConfig.backgroundColor)
                ? this.fileData.windowConfig.backgroundColor
                : '#ffffff';

            // ダイアログのHTML要素を作成
            const dialogHtml = `
                <div style="margin-bottom: 10px;">ウインドウ背景色を選択してください。</div>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center;">
                        <input type="checkbox" id="useLinkBgColor" style="margin-right: 5px;">
                        仮身背景色と同じ
                    </label>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px;">#FFFFFF形式で入力：</label>
                    <input type="text" id="bgColorInput" placeholder="#FFFFFF" value="${currentBgColor}"
                           style="width: 100%; padding: 5px; box-sizing: border-box;">
                </div>
            `;

            this.dialogCallbacks[messageId] = (result) => {
                if (result.button === 'ok') {
                    const useLinkBgColor = result.checkbox;
                    const inputColor = result.input;

                    let newBgColor;
                    if (useLinkBgColor && selectedVirtualObject) {
                        // 選択された仮身のbgcolを使用
                        newBgColor = selectedVirtualObject.bgcol || '#ffffff';
                    } else {
                        // 入力された色を使用
                        if (/^#[0-9A-Fa-f]{6}$/.test(inputColor)) {
                            newBgColor = inputColor;
                        } else {
                            console.warn('[VirtualObjectList] 無効な色形式:', inputColor);
                            return;
                        }
                    }

                    // キャンバスの背景色を変更
                    const canvas = document.querySelector('.virtual-canvas');
                    if (canvas) {
                        canvas.style.background = newBgColor;
                        console.log('[VirtualObjectList] 背景色を変更しました:', newBgColor);
                    }

                    // 実身管理用セグメントのbackgroundColorを更新
                    if (this.fileId && window.parent && window.parent !== window) {
                        window.parent.postMessage({
                            type: 'update-background-color',
                            fileId: this.fileId,
                            backgroundColor: newBgColor
                        }, '*');
                        console.log('[VirtualObjectList] 背景色更新を親ウィンドウに通知:', this.fileId, newBgColor);
                    }

                    // this.fileDataを更新（再表示時に正しい色を適用するため）
                    if (!this.fileData.windowConfig) {
                        this.fileData.windowConfig = {};
                    }
                    this.fileData.windowConfig.backgroundColor = newBgColor;
                }
                resolve(result);
            };

            // 親ウィンドウにカスタムダイアログ表示を要求
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'show-custom-dialog',
                    messageId: messageId,
                    dialogHtml: dialogHtml,
                    buttons: [
                        { label: '取消', value: 'cancel' },
                        { label: '設定', value: 'ok' }
                    ],
                    defaultButton: 1,
                    inputs: {
                        checkbox: 'useLinkBgColor',
                        text: 'bgColorInput'
                    }
                }, '*');
            }
        });
    }

    /**
     * TADファイルをXMLに変換（基本文章編集から移植）
     */
    async parseTADToXML(rawData) {
        if (window.parent && typeof window.parent.parseTADToXML === 'function') {
            try {
                const uint8Array = rawData instanceof Uint8Array ? rawData : new Uint8Array(rawData);
                const xmlResult = await window.parent.parseTADToXML(uint8Array, 0);
                console.log('[VirtualObjectList] XML変換完了:', xmlResult ? xmlResult.substring(0, 100) : 'null');
                return xmlResult;
            } catch (error) {
                console.error('[VirtualObjectList] TAD→XML変換エラー:', error);
                return null;
            }
        }
        console.warn('[VirtualObjectList] parseTADToXML関数が見つかりません');
        return null;
    }

    /**
     * TAD XMLから段落要素を抽出（基本文章編集から移植）
     */
    parseTextElements(tadXML) {
        console.log('[VirtualObjectList] parseTextElements開始');
        const textElements = [];

        const docMatch = /<document>([\s\S]*?)<\/document>/i.exec(tadXML);
        if (!docMatch) {
            console.warn('[VirtualObjectList] <document>タグが見つかりません');
            return textElements;
        }

        const docContent = docMatch[1];
        const paragraphRegex = /<p>([\s\S]*?)<\/p>/gi;
        let pMatch;

        while ((pMatch = paragraphRegex.exec(docContent)) !== null) {
            const paragraphContent = pMatch[1];

            const fontColorMatch = /<font\s+color="([^"]*)"\s*\/>/i.exec(paragraphContent);
            const fontColor = fontColorMatch ? fontColorMatch[1] : '';

            const fontSizeMatch = /<font\s+size="([^"]*)"\s*\/>/i.exec(paragraphContent);
            const fontSize = fontSizeMatch ? fontSizeMatch[1] : '14';

            const fontFaceMatch = /<font\s+face="([^"]*)"\s*\/>/i.exec(paragraphContent);
            const fontFamily = fontFaceMatch ? fontFaceMatch[1] : '';

            const textAlignMatch = /<text\s+align="([^"]*)"\s*\/>/i.exec(paragraphContent);
            const textAlign = textAlignMatch ? textAlignMatch[1] : 'left';

            const htmlContent = this.convertDecorationTagsToHTML(paragraphContent);

            const plainText = paragraphContent
                .replace(/\r\n/g, '')
                .replace(/\r/g, '')
                .replace(/<text[^>]*>/gi, '')
                .replace(/<\/text>/gi, '')
                .replace(/<font[^>]*\/>/gi, '')
                .replace(/<font[^>]*>/gi, '')
                .replace(/<\/font>/gi, '')
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<[^>]+>/g, '')
                .trim();

            if (plainText) {
                textElements.push({
                    fontSize: fontSize,
                    fontFamily: fontFamily,
                    fontColor: fontColor,
                    textAlign: textAlign,
                    content: plainText,
                    htmlContent: htmlContent,
                    rawXML: paragraphContent
                });
            } else {
                textElements.push({
                    fontSize: '14',
                    fontFamily: '',
                    fontColor: '',
                    textAlign: textAlign,
                    content: '',
                    rawXML: paragraphContent
                });
            }
        }

        console.log('[VirtualObjectList] parseTextElements完了, 要素数:', textElements.length);
        return textElements;
    }

    /**
     * TAD XML文字修飾タグをHTMLに変換（基本文章編集から移植）
     */
    convertDecorationTagsToHTML(content) {
        let html = content;

        // XMLの改行文字を削除（タグの外側の改行のみ）
        html = html.replace(/\n/g, '').replace(/\r/g, '');

        // <font>タグを処理（自己閉じタグのペア形式を処理）
        let result = '';
        let pos = 0;
        const fontRegex = /<font\s+(size|color|face)="([^"]*)"\s*\/>/g;
        let match;
        const stack = [];

        while ((match = fontRegex.exec(html)) !== null) {
            result += html.substring(pos, match.index);

            const attr = match[1];
            const value = match[2];

            if (value === '') {
                // 終了タグ
                for (let i = stack.length - 1; i >= 0; i--) {
                    if (stack[i].attr === attr) {
                        result += '</span>';
                        stack.splice(i, 1);
                        break;
                    }
                }
            } else {
                // 開始タグ
                let styleValue = '';
                if (attr === 'size') {
                    styleValue = `font-size: ${value}pt;`;
                } else if (attr === 'color') {
                    styleValue = `color: ${value};`;
                } else if (attr === 'face') {
                    styleValue = `font-family: ${value};`;
                }
                result += `<span style="${styleValue}">`;
                stack.push({ attr, value });
            }

            pos = fontRegex.lastIndex;
        }

        result += html.substring(pos);
        html = result;

        // 各種修飾タグの変換
        html = html.replace(/<underline>(.*?)<\/underline>/gi, '<u>$1</u>');
        html = html.replace(/<overline>(.*?)<\/overline>/gi, '<span style="text-decoration: overline;">$1</span>');
        html = html.replace(/<strikethrough>(.*?)<\/strikethrough>/gi, '<s>$1</s>');
        html = html.replace(/<bold>(.*?)<\/bold>/gi, '<b>$1</b>');
        html = html.replace(/<italic>(.*?)<\/italic>/gi, '<i>$1</i>');
        html = html.replace(/<superscript>(.*?)<\/superscript>/gi, '<sup>$1</sup>');
        html = html.replace(/<subscript>(.*?)<\/subscript>/gi, '<sub>$1</sub>');
        html = html.replace(/<bagchar>(.*?)<\/bagchar>/gi, '<span style="-webkit-text-stroke: 1px currentColor; paint-order: stroke fill;">$1</span>');
        html = html.replace(/<box>(.*?)<\/box>/gi, '<span style="border: 1px solid currentColor; padding: 0 2px;">$1</span>');
        html = html.replace(/<invert>(.*?)<\/invert>/gi, '<span style="background-color: currentColor; color: #ffffff; padding: 0 2px;">$1</span>');
        html = html.replace(/<mesh>(.*?)<\/mesh>/gi, '<span style="background-image: repeating-linear-gradient(45deg, transparent, transparent 2px, #00000019 2px, #00000019 4px);">$1</span>');
        html = html.replace(/<noprint>(.*?)<\/noprint>/gi, '<span style="opacity: 0.3;" data-noprint="true">$1</span>');

        // rubyタグ
        html = html.replace(/<ruby\s+position="([01])"\s+text="([^"]*)"\s*>(.*?)<\/ruby>/gi, (match, position, rubyText, baseText) => {
            if (position === '0') {
                return `<ruby>${baseText}<rt>${rubyText}</rt></ruby>`;
            } else {
                return `<ruby>${baseText}<rtc style="ruby-position: under;">${rubyText}</rtc></ruby>`;
            }
        });

        html = html.replace(/<br\s*\/>/gi, '<br>');

        return html;
    }

    /**
     * 仮身の内容をHTML形式で描画（基本文章編集のrenderTADXMLから移植）
     */
    renderVirtualObjectContent(xmlContent) {
        if (!xmlContent) {
            return '';
        }

        try {
            // <document>...</document>を抽出
            const docMatch = /<document>([\s\S]*?)<\/document>/i.exec(xmlContent);
            if (!docMatch) {
                return xmlContent;
            }

            const docContent = docMatch[1];

            // <p>タグで段落に分割
            const paragraphRegex = /<p>([\s\S]*?)<\/p>/gi;
            let htmlContent = '';
            let pMatch;

            while ((pMatch = paragraphRegex.exec(docContent)) !== null) {
                let paragraphContent = pMatch[1].trim();
                let style = 'margin: 0.5em 0;';

                // フォントサイズ
                const fontSizeMatch = /<font\s+size="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (fontSizeMatch) {
                    style += `font-size: ${fontSizeMatch[1]}pt;`;
                    paragraphContent = paragraphContent.replace(/<font\s+size="[^"]*"\s*\/>/i, '');
                }

                // フォントファミリー
                const fontFaceMatch = /<font\s+face="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (fontFaceMatch) {
                    style += `font-family: ${fontFaceMatch[1]};`;
                    paragraphContent = paragraphContent.replace(/<font\s+face="[^"]*"\s*\/>/i, '');
                }

                // フォントカラー
                const fontColorMatch = /<font\s+color="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (fontColorMatch) {
                    style += `color: ${fontColorMatch[1]};`;
                    paragraphContent = paragraphContent.replace(/<font\s+color="[^"]*"\s*\/>/i, '');
                }

                // テキスト配置
                const textAlignMatch = /<text\s+align="([^"]*)"\s*\/>/i.exec(paragraphContent);
                if (textAlignMatch) {
                    style += `text-align: ${textAlignMatch[1]};`;
                    paragraphContent = paragraphContent.replace(/<text\s+align="[^"]*"\s*\/>/gi, '');
                }

                // <text>タグを削除
                paragraphContent = paragraphContent.replace(/<text[^>]*\/>/gi, '');
                paragraphContent = paragraphContent.replace(/<text[^>]*>/gi, '').replace(/<\/text>/gi, '');

                // タグ間の余分な空白・改行を正規化
                paragraphContent = paragraphContent.replace(/>\s+</g, '><');

                // インライン修飾タグをHTMLに変換
                paragraphContent = this.convertDecorationTagsToHTML(paragraphContent);

                // 空の段落
                if (!paragraphContent.trim()) {
                    htmlContent += `<p style="${style}">&nbsp;</p>`;
                } else {
                    htmlContent += `<p style="${style}">${paragraphContent}</p>`;
                }
            }

            return htmlContent || xmlContent;
        } catch (error) {
            console.error('[VirtualObjectList] HTML変換エラー:', error);
            return xmlContent;
        }
    }

    /**
     * エディタの内容をTAD XMLに変換（基本文章編集から移植）
     */
    convertEditorToXML(editorElement) {
        console.log('[VirtualObjectList] convertEditorToXML開始');

        const xmlParts = ['<tad version="1.0" encoding="UTF-8">\r\n'];
        xmlParts.push('<document>\r\n');

        // エディタの各段落（<p>タグ）を処理
        const paragraphs = editorElement.querySelectorAll('p');
        console.log('[VirtualObjectList] 段落数:', paragraphs.length);

        if (paragraphs.length === 0) {
            // 段落がない場合、エディタ全体を1つの段落として扱う
            xmlParts.push('<p>\r\n');
            this.extractTADXMLFromElement(editorElement, xmlParts);
            xmlParts.push('\r\n</p>\r\n');
        } else {
            paragraphs.forEach((p) => {
                xmlParts.push('<p>\r\n');

                // 段落のスタイルを解析してタグに変換
                const fontSize = this.extractFontSize(p);
                const fontFamily = this.extractFontFamily(p);
                const color = this.extractColor(p);
                const textAlign = this.extractTextAlign(p);

                // text-align情報を自己閉じタグとして追加
                if (textAlign && textAlign !== 'left') {
                    xmlParts.push(`<text align="${textAlign}"/>`);
                }

                // フォント情報を自己閉じタグとして追加
                if (fontFamily) {
                    xmlParts.push(`<font face="${fontFamily}"/>`);
                }
                if (fontSize) {
                    xmlParts.push(`<font size="${fontSize}"/>`);
                }
                if (color) {
                    xmlParts.push(`<font color="${color}"/>`);
                }

                // 段落の内容を取得
                this.extractTADXMLFromElement(p, xmlParts);

                xmlParts.push('\r\n</p>\r\n');
            });
        }

        xmlParts.push('</document>\r\n');
        xmlParts.push('</tad>');

        const xml = xmlParts.join('');
        console.log('[VirtualObjectList] convertEditorToXML完了, XML長さ:', xml.length);
        return xml;
    }

    /**
     * 要素からTAD XMLタグを抽出（基本文章編集から移植）
     */
    extractTADXMLFromElement(element, xmlParts, fontState = { size: '9.6', color: '#000000', face: '' }) {
        // 後方互換性サポート: 第2引数が配列でない場合は旧形式の呼び出し
        const isOldStyle = !Array.isArray(xmlParts);
        if (isOldStyle) {
            fontState = xmlParts || { size: '9.6', color: '#000000', face: '' };
            xmlParts = [];
        }

        let xml = '';
        const nodes = element.childNodes;

        nodes.forEach(node => {
            if (node.nodeType === 3) { // Node.TEXT_NODE
                xml += this.escapeXml(node.textContent);
            } else if (node.nodeName === 'BR') {
                xml += '<br/>';
            } else if (node.nodeType === 1) { // Node.ELEMENT_NODE
                const nodeName = node.nodeName.toLowerCase();

                // TAD XMLタグはそのまま出力
                if (['underline', 'overline', 'strikethrough', 'bagchar', 'box', 'invert', 'mesh', 'noprint', 'ruby'].includes(nodeName)) {
                    xml += `<${nodeName}`;

                    if (nodeName === 'ruby') {
                        const position = node.getAttribute('position') || '0';
                        const text = node.getAttribute('text') || '';
                        xml += ` position="${position}" text="${this.escapeXml(text)}"`;
                    }

                    xml += '>';
                    xml += this.extractTADXMLFromElement(node, xmlParts, fontState);
                    xml += `</${nodeName}>`;
                }
                else if (nodeName === 'font') {
                    const color = this.rgbToHex(node.color || node.style.color);
                    const sizeAttr = node.size || this.extractFontSize(node);
                    const face = node.face || this.extractFontFamily(node);

                    const prevState = { ...fontState };
                    const newState = { ...fontState };

                    if (color) {
                        xml += `<font color="${color}"/>`;
                        newState.color = color;
                    }
                    if (sizeAttr) {
                        xml += `<font size="${sizeAttr}"/>`;
                        newState.size = sizeAttr;
                    }
                    if (face) {
                        xml += `<font face="${face}"/>`;
                        newState.face = face;
                    }

                    xml += this.extractTADXMLFromElement(node, xmlParts, newState);

                    if (face) {
                        xml += `<font face="${prevState.face}"/>`;
                    }
                    if (sizeAttr) {
                        xml += `<font size="${prevState.size}"/>`;
                    }
                    if (color) {
                        xml += `<font color="${prevState.color}"/>`;
                    }
                }
                else if (nodeName === 'b' || nodeName === 'strong') {
                    xml += '<bold>';
                    xml += this.extractTADXMLFromElement(node, xmlParts, fontState);
                    xml += '</bold>';
                }
                else if (nodeName === 'i' || nodeName === 'em') {
                    xml += '<italic>';
                    xml += this.extractTADXMLFromElement(node, xmlParts, fontState);
                    xml += '</italic>';
                }
                else if (nodeName === 'u') {
                    xml += '<underline>';
                    xml += this.extractTADXMLFromElement(node, xmlParts, fontState);
                    xml += '</underline>';
                }
                else if (nodeName === 'sup') {
                    xml += '<superscript>';
                    xml += this.extractTADXMLFromElement(node, xmlParts, fontState);
                    xml += '</superscript>';
                }
                else if (nodeName === 'sub') {
                    xml += '<subscript>';
                    xml += this.extractTADXMLFromElement(node, xmlParts, fontState);
                    xml += '</subscript>';
                }
                else if (nodeName === 'span') {
                    const style = node.style;
                    const prevState = { ...fontState };
                    const newState = { ...fontState };

                    if (style.color) {
                        const hexColor = this.rgbToHex(style.color);
                        xml += `<font color="${hexColor}"/>`;
                        newState.color = hexColor;
                    }
                    if (style.fontSize) {
                        const size = style.fontSize.replace('pt', '');
                        xml += `<font size="${size}"/>`;
                        newState.size = size;
                    }
                    if (style.fontFamily) {
                        xml += `<font face="${style.fontFamily}"/>`;
                        newState.face = style.fontFamily;
                    }

                    xml += this.extractTADXMLFromElement(node, xmlParts, newState);

                    if (style.fontFamily) {
                        xml += `<font face="${prevState.face}"/>`;
                    }
                    if (style.fontSize) {
                        xml += `<font size="${prevState.size}"/>`;
                    }
                    if (style.color) {
                        xml += `<font color="${prevState.color}"/>`;
                    }
                }
                else {
                    xml += this.extractTADXMLFromElement(node, xmlParts, fontState);
                }
            }
        });

        // 配列に追加
        if (xml) {
            xmlParts.push(xml);
        }

        // 旧形式の呼び出しの場合は文字列を返す
        if (isOldStyle) {
            return xmlParts.join('');
        }
    }

    /**
     * XMLエスケープ（基本文章編集から移植）
     */
    escapeXml(text) {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    }

    /**
     * RGB形式を#rrggbb形式に変換（基本文章編集から移植）
     */
    rgbToHex(color) {
        if (!color) return '';

        if (color.startsWith('#')) {
            return color;
        }

        const rgbMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
        if (rgbMatch) {
            const r = parseInt(rgbMatch[1], 10);
            const g = parseInt(rgbMatch[2], 10);
            const b = parseInt(rgbMatch[3], 10);
            return '#' + [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
        }

        return color;
    }

    /**
     * フォントサイズを抽出（基本文章編集から移植）
     */
    extractFontSize(element) {
        const style = element.style.fontSize;
        if (style) {
            return style.replace('pt', '');
        }
        return null;
    }

    /**
     * フォントファミリーを抽出（基本文章編集から移植）
     */
    extractFontFamily(element) {
        const style = element.style.fontFamily;
        if (style) {
            return style.replace(/['"]/g, '');
        }
        return null;
    }

    /**
     * 色を抽出（基本文章編集から移植）
     */
    extractColor(element) {
        const style = element.style.color;
        if (style) {
            return style;
        }
        return null;
    }

    /**
     * テキスト配置を抽出（基本文章編集から移植）
     */
    extractTextAlign(element) {
        const style = element.style.textAlign;
        if (style) {
            return style;
        }
        return 'left';
    }

    async parseVirtualObjects() {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(this.xmlData, 'text/xml');

            // すべての<link>要素を取得（仮身として表示）
            const linkElements = xmlDoc.getElementsByTagName('link');

            this.virtualObjects = [];

            for (const link of linkElements) {
                const virtualObj = this.parseLinkElement(link);
                if (virtualObj) {
                    // 仮身のlink_idに対応するJSONファイルを読み込んでapplist情報を取得
                    await this.loadVirtualObjectMetadata(virtualObj);
                    this.virtualObjects.push(virtualObj);
                }
            }

            console.log('[VirtualObjectList] 仮身数:', this.virtualObjects.length);

            // autoopen属性がtrueの仮身を自動的に開く
            await this.autoOpenVirtualObjects();
        } catch (error) {
            console.error('[VirtualObjectList] XML解析エラー:', error);
        }
    }

    /**
     * 親ウィンドウにファイル読み込みを依頼
     */
    async loadDataFileFromParent(fileName) {
        return new Promise((resolve, reject) => {
            const requestId = `load-${Date.now()}-${Math.random()}`;

            const messageHandler = (event) => {
                if (event.data && event.data.type === 'load-data-file-response' && event.data.requestId === requestId) {
                    window.removeEventListener('message', messageHandler);
                    if (event.data.success) {
                        resolve(event.data.data);
                    } else {
                        reject(new Error(event.data.error || 'ファイル読み込み失敗'));
                    }
                }
            };

            window.addEventListener('message', messageHandler);

            window.parent.postMessage({
                type: 'load-data-file-request',
                requestId: requestId,
                fileName: fileName
            }, '*');

            // 5秒でタイムアウト
            setTimeout(() => {
                window.removeEventListener('message', messageHandler);
                reject(new Error('タイムアウト'));
            }, 5000);
        });
    }

    /**
     * アイコンファイルを親ウィンドウ経由で読み込む
     * @param {string} realId - 実身ID
     * @returns {Promise<string|null>} Base64エンコードされたアイコンデータ、またはnull
     */
    async loadIconFromParent(realId) {
        // キャッシュをチェック
        if (this.iconCache.has(realId)) {
            const cachedData = this.iconCache.get(realId);
            console.log('[BTRON] アイコンキャッシュヒット:', realId, 'データあり:', !!cachedData);
            return cachedData;
        }

        console.log('[BTRON] アイコンキャッシュミス、親ウィンドウに要求:', realId);
        return new Promise((resolve) => {
            let resolved = false; // resolveされたかどうかのフラグ

            const messageHandler = (event) => {
                if (event.data && event.data.type === 'icon-file-loaded' && event.data.realId === realId) {
                    if (resolved) return; // 既にresolveされていたら何もしない
                    resolved = true;
                    window.removeEventListener('message', messageHandler);

                    if (event.data.success) {
                        // キャッシュに保存
                        this.iconCache.set(realId, event.data.data);
                        console.log('[BTRON] アイコン読み込み成功（親から）:', realId, 'データ長:', event.data.data.length);
                        resolve(event.data.data);
                    } else {
                        // アイコンが存在しない場合はnullを返す
                        this.iconCache.set(realId, null);
                        console.log('[BTRON] アイコン読み込み失敗（親から）:', realId);
                        resolve(null);
                    }
                }
            };

            window.addEventListener('message', messageHandler);

            window.parent.postMessage({
                type: 'read-icon-file',
                realId: realId
            }, '*');

            // 3秒でタイムアウト（アイコンがない場合も多いのでnullを返す）
            setTimeout(() => {
                if (resolved) return; // 既にresolveされていたら何もしない
                resolved = true;
                window.removeEventListener('message', messageHandler);
                // キャッシュにまだ入っていない場合のみnullをセット
                if (!this.iconCache.has(realId)) {
                    this.iconCache.set(realId, null);
                }
                console.log('[BTRON] アイコン読み込みタイムアウト:', realId);
                resolve(null);
            }, 3000);
        });
    }

    /**
     * 仮身のメタデータ（applist等）をJSONファイルから読み込む
     * @param {Object} virtualObj - 仮身オブジェクト
     */
    async loadVirtualObjectMetadata(virtualObj) {
        try {
            // _[recordno].xtad パターンを取り除いてベースファイルIDを取得
            const baseFileId = virtualObj.link_id.replace(/_\d+\.xtad$/i, '');
            const jsonFileName = `${baseFileId}.json`;
            console.log('[VirtualObjectList] メタデータ読み込み試行:', virtualObj.link_id, 'JSONファイル:', jsonFileName);

            // 親ウィンドウのfileObjectsからJSONファイルを取得
            if (window.parent && window.parent.tadjsDesktop && window.parent.tadjsDesktop.fileObjects) {
                const jsonFile = window.parent.tadjsDesktop.fileObjects[jsonFileName];
                console.log('[VirtualObjectList] fileObjectsから検索:', jsonFileName, 'found:', !!jsonFile);

                if (jsonFile) {
                    const jsonText = await jsonFile.text();
                    const jsonData = JSON.parse(jsonText);

                    // applistはオブジェクト形式 { "plugin-id": { "name": "プラグイン名" }, ... }
                    virtualObj.applist = jsonData.applist || {};
                    virtualObj.metadata = jsonData;
                    virtualObj.updateDate = jsonData.updateDate; // 更新日時を保存
                    console.log('[VirtualObjectList] メタデータ読み込み成功:', virtualObj.link_id, virtualObj.applist);
                } else {
                    // JSONファイルが見つからない場合、Electron環境なら親ウィンドウ経由で読み込み
                    console.log('[VirtualObjectList] fileObjectsに見つからない、親ウィンドウ経由で試行:', jsonFileName);

                    try {
                        const jsonFile = await this.loadDataFileFromParent(jsonFileName);
                        const jsonText = await jsonFile.text();
                        const jsonData = JSON.parse(jsonText);
                        virtualObj.applist = jsonData.applist || {};
                        virtualObj.metadata = jsonData;
                        virtualObj.updateDate = jsonData.updateDate; // 更新日時を保存
                        console.log('[VirtualObjectList] メタデータ読み込み成功（親ウィンドウ経由）:', jsonFileName, virtualObj.applist);
                    } catch (parentError) {
                        console.log('[VirtualObjectList] 親ウィンドウ経由で失敗、HTTP fetchにフォールバック:', parentError.message);

                        // HTTP fetchにフォールバック
                        const urlsToTry = [
                            `../../${jsonFileName}`,  // resources/app/
                            `../basic-text-editor/${jsonFileName}`,
                            `../unpack-file/${jsonFileName}`,
                            `../virtual-object-list/${jsonFileName}`,
                            `../base-file-manager/${jsonFileName}`,
                            `../system-config/${jsonFileName}`,
                            `../user-config/${jsonFileName}`,
                            `../tadjs-view/${jsonFileName}`
                        ];

                        let found = false;
                        for (const jsonUrl of urlsToTry) {
                            console.log('[VirtualObjectList] Fetch URL試行:', jsonUrl);
                            const response = await fetch(jsonUrl);

                            if (response.ok) {
                                const jsonData = await response.json();
                                virtualObj.applist = jsonData.applist || {};
                                virtualObj.metadata = jsonData;
                                virtualObj.updateDate = jsonData.updateDate; // 更新日時を保存
                                console.log('[VirtualObjectList] メタデータ読み込み成功（HTTP）:', jsonUrl, virtualObj.applist);
                                found = true;
                                break;
                            }
                        }

                        if (!found) {
                            console.log('[VirtualObjectList] JSONファイルなし（すべてのパスで404）:', virtualObj.link_id);
                            virtualObj.applist = {};
                        }
                    }
                }
            } else {
                // 親ウィンドウのfileObjectsにアクセスできない場合（親ウィンドウ経由で読み込み）
                console.log('[VirtualObjectList] 親ウィンドウのfileObjectsにアクセスできない、親ウィンドウ経由で読み込み');

                try {
                    const jsonFile = await this.loadDataFileFromParent(jsonFileName);
                    const jsonText = await jsonFile.text();
                    const jsonData = JSON.parse(jsonText);
                    virtualObj.applist = jsonData.applist || {};
                    virtualObj.metadata = jsonData;
                    virtualObj.updateDate = jsonData.updateDate; // 更新日時を保存
                    console.log('[VirtualObjectList] メタデータ読み込み成功（親ウィンドウ経由）:', jsonFileName, virtualObj.applist);
                } catch (error) {
                    console.log('[VirtualObjectList] メタデータ読み込み失敗:', virtualObj.link_id, error.message);
                    virtualObj.applist = {};
                }
            }
        } catch (error) {
            console.log('[VirtualObjectList] メタデータ読み込みエラー:', virtualObj.link_id, error);
            virtualObj.applist = {};
        }
    }

    /**
     * <link>要素から仮身情報を解析
     */
    parseLinkElement(linkElement) {
        try {
            const vobjleft = parseInt(linkElement.getAttribute('vobjleft')) || 0;
            const vobjtop = parseInt(linkElement.getAttribute('vobjtop')) || 0;
            const vobjright = parseInt(linkElement.getAttribute('vobjright')) || 0;
            const vobjbottom = parseInt(linkElement.getAttribute('vobjbottom')) || 0;

            const obj = {
                link_id: linkElement.getAttribute('id') || '',
                vobjleft: vobjleft,
                vobjtop: vobjtop,
                vobjright: vobjright,
                vobjbottom: vobjbottom,
                // 元の位置を保存（<link>要素を一意に識別するため）
                originalLeft: vobjleft,
                originalTop: vobjtop,
                originalRight: vobjright,
                originalBottom: vobjbottom,
                height: parseInt(linkElement.getAttribute('height')) || 0,
                chsz: parseInt(linkElement.getAttribute('chsz')) || 14,  // 仮身表示名の文字サイズ
                frcol: linkElement.getAttribute('frcol') || '#000000',   // 仮身の枠の色
                chcol: linkElement.getAttribute('chcol') || '#000000',   // 仮身表示名の文字色
                tbcol: linkElement.getAttribute('tbcol') || '#ffffff',   // 仮身の背景色
                bgcol: linkElement.getAttribute('bgcol') || '#ffffff',   // 開いた仮身の表示領域の背景色
                dlen: parseInt(linkElement.getAttribute('dlen')) || 0,
                link_name: linkElement.textContent.trim() || '無題の仮身',
                // 表示属性
                pictdisp: linkElement.getAttribute('pictdisp') || 'true',
                namedisp: linkElement.getAttribute('namedisp') || 'true',
                roledisp: linkElement.getAttribute('roledisp') || 'false',
                typedisp: linkElement.getAttribute('typedisp') || 'false',
                updatedisp: linkElement.getAttribute('updatedisp') || 'false',
                framedisp: linkElement.getAttribute('framedisp') || 'true',
                autoopen: linkElement.getAttribute('autoopen') || 'false'
            };

            // 位置・サイズを計算
            obj.width = obj.vobjright - obj.vobjleft;
            obj.height_px = obj.vobjbottom - obj.vobjtop;

            return obj;
        } catch (error) {
            console.error('[VirtualObjectList] リンク要素解析エラー:', error);
            return null;
        }
    }

    parseVirtualObjectSegment(segment) {
        try {
            const obj = {
                id: segment.getAttribute('id') || '',
                x: parseInt(segment.getAttribute('x')) || 0,
                y: parseInt(segment.getAttribute('y')) || 0,
                width: parseInt(segment.getAttribute('width')) || 0,
                height: parseInt(segment.getAttribute('height')) || 0,
                name: '',
                type: '',
                dataLength: 0,
                data: null,
                segment: segment
            };

            // 仮身データを取得
            const dataElement = segment.querySelector('virtual-data, link-data');
            if (dataElement) {
                const xmlContent = dataElement.textContent.trim();
                obj.data = xmlContent;
                obj.dataLength = xmlContent.length;

                // XML内容をHTML形式に変換
                obj.htmlContent = this.renderVirtualObjectContent(xmlContent);

                // 仮身名を推測（最初の段落から）
                const nameMatch = /<p>(.*?)<\/p>/i.exec(xmlContent);
                if (nameMatch) {
                    const firstPara = nameMatch[1].replace(/<[^>]+>/g, '').trim();
                    obj.name = firstPara.substring(0, 50);
                }
            }

            // セグメント内のtype属性があれば取得
            const typeAttr = segment.getAttribute('virtual-type') || segment.getAttribute('link-type');
            if (typeAttr) {
                obj.type = typeAttr;
            } else {
                obj.type = segment.querySelector('virtual-data') ? '仮身' : 'リンク';
            }

            return obj;
        } catch (error) {
            console.error('[VirtualObjectList] 仮身セグメント解析エラー:', error);
            return null;
        }
    }

    renderVirtualObjects() {
        const listElement = document.getElementById('virtualList');
        if (!listElement) return;

        // 現在展開されている（iframeを持つ）仮身を記録
        const expandedVirtualObjects = new Set();
        const existingVirtualObjects = listElement.querySelectorAll('.virtual-object-opened');
        existingVirtualObjects.forEach(vobj => {
            // iframeを持つ仮身だけを記録
            const iframe = vobj.querySelector('iframe');
            if (iframe) {
                const linkName = vobj.getAttribute('data-link-name');
                if (linkName) {
                    expandedVirtualObjects.add(linkName);
                    console.log('[VirtualObjectList] 展開中の仮身を記録:', linkName);
                }
            }
        });

        listElement.innerHTML = '';

        // 仮身の最大の右端・下端位置を計算
        let maxRight = 0;
        let maxBottom = 0;

        this.virtualObjects.forEach((obj) => {
            const right = obj.vobjright || (obj.vobjleft + (obj.width || 100));
            const bottom = obj.vobjbottom || (obj.vobjtop + (obj.height_px || 100));

            maxRight = Math.max(maxRight, right);
            maxBottom = Math.max(maxBottom, bottom);
        });

        // 実際のコンテンツサイズにマージンを追加し、小さな最小値を設定
        maxRight = Math.max(maxRight + 50, 300);  // 最小300px
        maxBottom = Math.max(maxBottom + 50, 200); // 最小200px

        // 仮身を配置するためのキャンバスを作成
        const canvas = document.createElement('div');
        canvas.className = 'virtual-canvas';
        canvas.style.position = 'relative';

        // ウィンドウサイズを取得
        const pluginContent = document.querySelector('.plugin-content');
        const windowWidth = pluginContent ? pluginContent.clientWidth : 300;
        const windowHeight = pluginContent ? pluginContent.clientHeight : 200;

        // コンテンツサイズとウィンドウサイズの大きい方を採用
        const finalWidth = Math.max(maxRight, windowWidth);
        const finalHeight = Math.max(maxBottom, windowHeight);

        canvas.style.width = finalWidth + 'px';   // 動的に幅を設定
        canvas.style.height = finalHeight + 'px'; // 動的に高さを設定
        // 背景色はapplyBackgroundColor()で設定
        canvas.style.border = '1px solid #808080';

        this.virtualObjects.forEach((obj) => {
            const vobjElement = this.createVirtualObjectElement(obj);
            canvas.appendChild(vobjElement);

            // 開いた仮身は自動展開（初回起動時 or 以前展開されていた場合）
            const vobjHeight = obj.vobjbottom - obj.vobjtop;
            const chsz = Math.round(obj.chsz || 14); // 浮動小数点誤差を防ぐ
            const lineHeight = 1.2;
            const chszPx = window.convertPtToPx(chsz);
            const textHeight = Math.ceil(chszPx * lineHeight);
            const minOpenHeight = textHeight + 28; // タイトルバー + 区切り線 + コンテンツ最小
            const isOpenVirtualObj = vobjHeight >= minOpenHeight;
            if (isOpenVirtualObj) {
                // 初回起動時またはrefresh時に開いた仮身を展開
                if (!expandedVirtualObjects.has(obj.link_name)) {
                    console.log('[VirtualObjectList] 開いた仮身を自動展開:', obj.link_name);
                } else {
                    console.log('[VirtualObjectList] 仮身を再展開:', obj.link_name);
                }
                // 非同期で展開（DOMに追加された後に実行）
                setTimeout(() => {
                    this.expandVirtualObject(vobjElement, obj, {
                        readonly: true,
                        noScrollbar: true,
                        bgcol: obj.bgcol
                    }).catch(err => {
                        console.error('[VirtualObjectList] 展開エラー:', err);
                    });
                }, 0);
            }
        });

        listElement.appendChild(canvas);

        // スクロールバー更新を通知
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'update-scrollbars'
            }, '*');
        }

        // 背景色を適用
        this.applyBackgroundColor();
    }

    /**
     * 仮身要素を作成（VirtualObjectRendererを使用）
     * @param {Object} obj - 仮身オブジェクト
     * @returns {HTMLElement} - 仮身要素
     */
    createVirtualObjectElement(obj) {
        // VirtualObjectRendererを使用して仮身要素を作成
        if (!this.virtualObjectRenderer) {
            console.error('[VirtualObjectList] VirtualObjectRenderer が初期化されていません');
            return document.createElement('div');
        }

        // loadIconCallbackオプションでアイコン読み込み機能を提供
        const options = {
            loadIconCallback: (realId) => this.loadIconFromParent(realId)
        };

        const vobj = this.virtualObjectRenderer.createBlockElement(obj, options);

        // イベントリスナーを追加
        this.attachVirtualObjectEventListeners(vobj, obj);

        return vobj;
    }

    /**
     * 仮身要素にイベントリスナーを追加
     * @param {HTMLElement} vobj - 仮身要素
     * @param {Object} obj - 仮身オブジェクト
     */
    attachVirtualObjectEventListeners(vobj, obj) {
        // 仮身全体のクリックで選択
        vobj.addEventListener('click', (e) => {
            // 読み取り専用モードの場合は選択を無効化
            if (this.isReadonly) {
                return;
            }
            e.stopPropagation();
            this.selectVirtualObject(obj, vobj, e);
        });

        // 仮身全体のダブルクリックで開く
        vobj.addEventListener('dblclick', (e) => {
            // 読み取り専用モードの場合はダブルクリックを無効化
            if (this.isReadonly) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();
            console.log('[VirtualObjectList] 仮身ダブルクリック:', obj.link_name, obj.link_id);

            // 開いた仮身（expandedクラスがある）の場合は、defaultOpenプラグインで実身を起動
            if (vobj.classList.contains('expanded')) {
                console.log('[VirtualObjectList] 開いた仮身をdefaultOpenで起動:', obj.link_name);

                // applistからdefaultOpenプラグインを取得
                const applist = obj.applist || {};
                let defaultOpenPlugin = null;

                for (const [pluginId, config] of Object.entries(applist)) {
                    if (config.defaultOpen === true) {
                        defaultOpenPlugin = pluginId;
                        break;
                    }
                }

                if (defaultOpenPlugin) {
                    console.log('[VirtualObjectList] defaultOpenプラグイン:', defaultOpenPlugin);

                    // 親ウィンドウに実身を開くよう要求
                    window.parent.postMessage({
                        type: 'open-virtual-object-real',
                        virtualObj: obj,
                        pluginId: defaultOpenPlugin
                    }, '*');
                } else {
                    console.warn('[VirtualObjectList] defaultOpenプラグインが見つかりません');
                }
            } else {
                // 閉じた仮身の場合は、既存の動作（別ウィンドウで開く）
                this.openVirtualObject(obj);
            }
        });

        // 位置変更機能（ドラッグ）を追加
        this.makeVirtualObjectDraggable(vobj, obj);

        // サイズ変更機能（リサイズ）を追加
        this.makeVirtualObjectResizable(vobj, obj);
    }

    /**
     * 閉じた仮身を作成（tad.jsの7856-7884行を参考）
     * @param {Object} obj - 仮身オブジェクト
     * @returns {HTMLElement} - 閉じた仮身要素
     */
    createClosedVirtualObject(obj) {
        const vobj = document.createElement('div');
        vobj.className = 'virtual-object virtual-object-closed';
        vobj.setAttribute('data-link-name', obj.link_name); // 仮身識別用の属性
        vobj.style.position = 'absolute';
        vobj.style.left = obj.vobjleft + 'px';
        vobj.style.top = obj.vobjtop + 'px';
        vobj.style.width = obj.width + 'px';
        vobj.style.height = (obj.vobjbottom - obj.vobjtop) + 'px';
        vobj.style.boxSizing = 'border-box';
        vobj.style.cursor = 'pointer';

        // 表示項目の設定を取得
        const showName = obj.namedisp !== 'false'; // デフォルトは表示
        const showUpdate = obj.updatedisp === 'true'; // デフォルトは非表示
        const showFrame = obj.framedisp !== 'false'; // デフォルトは表示
        const showPict = obj.pictdisp !== 'false'; // デフォルトは表示
        const showRole = obj.roledisp === 'true'; // デフォルトは非表示
        const showType = obj.typedisp === 'true'; // デフォルトは非表示

        // いずれかの表示項目がある場合のみタイトルエリアを表示
        const showTitleArea = showPict || showName || showRole || showType || showUpdate;

        // デバッグログ: 表示フラグの状態を確認
        console.log('[BTRON] 閉仮身表示フラグ:', obj.link_id);
        console.log('  - フラグ値:', JSON.stringify({
            pictdisp: obj.pictdisp,
            namedisp: obj.namedisp,
            roledisp: obj.roledisp,
            typedisp: obj.typedisp,
            updatedisp: obj.updatedisp,
            framedisp: obj.framedisp
        }));
        console.log('  - 計算結果:', JSON.stringify({
            showPict, showName, showRole, showType, showUpdate, showFrame, showTitleArea
        }));
        console.log('  - データ:', JSON.stringify({
            hasMetadata: !!obj.metadata,
            hasUpdateDate: !!(obj.metadata && obj.metadata.updateDate),
            hasRelationship: !!(obj.metadata && obj.metadata.relationship),
            hasApplist: !!obj.applist,
            link_name: obj.link_name
        }));

        // タイトル部分（左上の領域）
        const titleArea = document.createElement('div');
        titleArea.style.position = 'absolute';
        titleArea.style.left = '0';
        titleArea.style.top = '0';
        titleArea.style.right = '0'; // 全幅
        // chszはポイント（pt）なのでピクセル（px）に変換
        const lineHeight = 1.2;
        const chszPx = window.convertPtToPx(obj.chsz);
        const textHeight = Math.ceil(chszPx * lineHeight);
        // アイコンサイズも計算（テキストとアイコンの両方を表示する場合に必要）
        const iconSize = window.convertPtToPx ? window.convertPtToPx(obj.chsz) : Math.round(obj.chsz * 1.333);
        // アイコンとテキストの高い方を使用
        const contentHeight = Math.max(iconSize, textHeight);
        const titleHeight = contentHeight + 8;
        console.log('[BTRON] 閉仮身タイトル高さ計算:', obj.link_name, {
            chsz: obj.chsz,
            chszPx,
            iconSize,
            textHeight,
            contentHeight,
            titleHeight,
            vobjHeight: (obj.vobjbottom - obj.vobjtop)
        });
        titleArea.style.height = titleHeight + 'px'; // コンテンツ高さ + パディング(上下各4px)
        titleArea.style.backgroundColor = obj.tbcol;

        // 仮身枠の表示/非表示
        if (showFrame) {
            titleArea.style.borderLeft = `1px solid ${obj.frcol}`;
            titleArea.style.borderTop = `1px solid ${obj.frcol}`;
            titleArea.style.borderRight = `1px solid ${obj.frcol}`;
        }

        titleArea.style.display = showTitleArea ? 'flex' : 'none';
        titleArea.style.alignItems = 'center';
        titleArea.style.paddingTop = '4px'; // 上下パディングを増やして中央寄せを改善
        titleArea.style.paddingBottom = '4px';
        titleArea.style.paddingLeft = '4px';
        titleArea.style.paddingRight = '4px';
        titleArea.style.gap = '4px';
        titleArea.style.overflow = 'visible'; // アイコンとテキストが切れないように
        titleArea.style.zIndex = '1'; // mainAreaの上に表示

        // ピクトグラム（アイコン）
        if (showPict) {
            const iconImg = document.createElement('img');
            iconImg.className = 'virtual-object-icon';
            // 既に計算済みのiconSizeを使用
            iconImg.style.width = iconSize + 'px';
            iconImg.style.height = iconSize + 'px';
            iconImg.style.objectFit = 'contain';
            iconImg.style.flexShrink = '0'; // アイコンは縮小しない
            iconImg.setAttribute('data-element-type', 'icon'); // オーバーフロー判定用

            // link_idから実身IDを抽出（_0.xtadなどを削除）
            const realId = obj.link_id.replace(/_\d+\.xtad$/i, '');

            // アイコンを非同期で読み込む
            console.log('[BTRON] アイコン読み込み開始:', realId, 'showPict:', showPict);
            this.loadIconFromParent(realId).then(iconData => {
                console.log('[BTRON] アイコン読み込みPromiseコールバック実行:', realId, 'データあり:', !!iconData);
                if (iconData) {
                    iconImg.src = `data:image/x-icon;base64,${iconData}`;
                    console.log('[BTRON] アイコンimg.src設定完了:', realId, 'データ長:', iconData.length);
                } else {
                    // デフォルトアイコン（空の画像または絵文字）
                    iconImg.style.display = 'none';
                    console.log('[BTRON] アイコンデータなし、非表示に設定:', realId);
                }
            }).catch(error => {
                console.error('[BTRON] アイコン読み込みエラー:', realId, error);
                iconImg.style.display = 'none';
            });

            titleArea.appendChild(iconImg);
        }

        // タイトルテキスト部分
        const titleTextSpan = document.createElement('span');
        titleTextSpan.className = 'virtual-object-title';
        titleTextSpan.style.color = obj.chcol;
        titleTextSpan.style.fontSize = chszPx + 'px';  // 既に計算されたピクセル値を使用
        titleTextSpan.style.whiteSpace = 'nowrap';
        titleTextSpan.style.overflow = 'hidden';
        titleTextSpan.style.textOverflow = 'ellipsis';
        titleTextSpan.style.lineHeight = '1.2';
        titleTextSpan.style.flex = '1';
        titleTextSpan.style.textDecoration = 'none'; // アンダーラインを防止

        // 名称
        if (showName) {
            const nameSpan = document.createElement('span');
            nameSpan.textContent = obj.link_name;
            nameSpan.style.textDecoration = 'none'; // アンダーラインを防止
            nameSpan.setAttribute('data-element-type', 'name');
            titleTextSpan.appendChild(nameSpan);
        }

        // 続柄（relationship配列をスペース区切りで表示）
        if (showRole && obj.metadata && obj.metadata.relationship && obj.metadata.relationship.length > 0) {
            const relationshipText = obj.metadata.relationship.join(' ');
            const relationshipSpan = document.createElement('span');
            relationshipSpan.textContent = ' : ' + relationshipText;
            relationshipSpan.setAttribute('data-element-type', 'relationship');
            titleTextSpan.appendChild(relationshipSpan);
        }

        // タイプ（applistから取得）
        if (showType && obj.applist) {
            // defaultOpenプラグインの名前を取得
            let typeName = '';
            for (const [, config] of Object.entries(obj.applist)) {
                if (config && config.defaultOpen === true && config.name) {
                    typeName = config.name;
                    break;
                }
            }

            if (typeName) {
                const typeSpan = document.createElement('span');
                typeSpan.textContent = ' (' + typeName + ')';
                typeSpan.setAttribute('data-element-type', 'type');
                titleTextSpan.appendChild(typeSpan);
            }
        }

        // 更新日時
        if (showUpdate && obj.metadata && obj.metadata.updateDate) {
            const updateDate = new Date(obj.metadata.updateDate);
            const dateStr = updateDate.getFullYear() + '/' +
                          String(updateDate.getMonth() + 1).padStart(2, '0') + '/' +
                          String(updateDate.getDate()).padStart(2, '0') + ' ' +
                          String(updateDate.getHours()).padStart(2, '0') + ':' +
                          String(updateDate.getMinutes()).padStart(2, '0') + ':' +
                          String(updateDate.getSeconds()).padStart(2, '0');
            const updateSpan = document.createElement('span');
            updateSpan.textContent = ' ' + dateStr;
            updateSpan.setAttribute('data-element-type', 'update');
            titleTextSpan.appendChild(updateSpan);
        }

        titleArea.appendChild(titleTextSpan);
        vobj.appendChild(titleArea);

        // メイン領域（タイトル下の本体部分）
        const mainArea = document.createElement('div');
        mainArea.style.position = 'absolute';
        mainArea.style.left = '0';
        mainArea.style.top = showTitleArea ? titleHeight + 'px' : '0'; // titleAreaの高さと一致させる
        mainArea.style.right = '0';
        mainArea.style.bottom = '0';
        mainArea.style.backgroundColor = obj.tbcol;
        mainArea.style.zIndex = '0'; // titleAreaの下に表示
        console.log('[BTRON] 閉仮身mainArea配置:', obj.link_name, {
            top: mainArea.style.top,
            zIndex: mainArea.style.zIndex
        });

        // 仮身枠の表示/非表示
        if (showFrame) {
            mainArea.style.border = `1px solid ${obj.frcol}`;
            if (showTitleArea) {
                mainArea.style.borderTop = 'none'; // タイトル領域と繋がっている場合は上の境界線は不要
            }
        }

        vobj.appendChild(mainArea);

        // 仮身全体のクリックで選択
        vobj.addEventListener('click', (e) => {
            // 読み取り専用モードの場合は選択を無効化
            if (this.isReadonly) {
                return;
            }
            e.stopPropagation();
            this.selectVirtualObject(obj, vobj, e);
        });

        // 仮身全体のダブルクリックで開く
        vobj.addEventListener('dblclick', (e) => {
            // 読み取り専用モードの場合はダブルクリックを無効化
            if (this.isReadonly) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();
            console.log('[VirtualObjectList] 仮身ダブルクリック:', obj.link_name, obj.link_id);

            // 開いた仮身（expandedクラスがある）の場合は、defaultOpenプラグインで実身を起動
            if (vobj.classList.contains('expanded')) {
                console.log('[VirtualObjectList] 開いた仮身をdefaultOpenで起動:', obj.link_name);

                // applistからdefaultOpenプラグインを取得
                const applist = obj.applist || {};
                let defaultOpenPlugin = null;

                for (const [pluginId, config] of Object.entries(applist)) {
                    if (config.defaultOpen === true) {
                        defaultOpenPlugin = pluginId;
                        break;
                    }
                }

                if (defaultOpenPlugin) {
                    console.log('[VirtualObjectList] defaultOpenプラグイン:', defaultOpenPlugin);

                    // 親ウィンドウに実身を開くよう要求
                    window.parent.postMessage({
                        type: 'open-virtual-object-real',
                        virtualObj: obj,
                        pluginId: defaultOpenPlugin
                    }, '*');
                } else {
                    console.warn('[VirtualObjectList] defaultOpenプラグインが見つかりません');
                }
            } else {
                // 閉じた仮身の場合は、既存の動作（別ウィンドウで開く）
                this.openVirtualObject(obj);
            }
        });

        // 位置変更機能（ドラッグ）を追加
        this.makeVirtualObjectDraggable(vobj, obj);

        // サイズ変更機能（リサイズ）を追加
        this.makeVirtualObjectResizable(vobj, obj);

        return vobj;
    }

    /**
     * 仮身を選択状態にする
     * @param {Object} obj - 選択する仮身オブジェクト
     * @param {HTMLElement} element - 仮身のDOM要素
     * @param {Event} event - クリックイベント（Shiftキー判定用）
     */
    selectVirtualObject(obj, element, event) {
        const isShiftKey = event && event.shiftKey;

        if (isShiftKey) {
            // Shift+クリック: 複数選択のトグル
            if (this.selectedVirtualObjects.has(obj)) {
                // 既に選択されている場合は解除
                this.selectedVirtualObjects.delete(obj);
                element.style.outline = '';
                console.log('[VirtualObjectList] 仮身の選択を解除:', obj.link_name);
            } else {
                // 選択されていない場合は追加
                this.selectedVirtualObjects.add(obj);
                element.style.outline = '2px solid #007bff';
                console.log('[VirtualObjectList] 仮身を選択（複数選択）:', obj.link_name);
            }
        } else {
            // 通常クリック: 単一選択
            // 以前の選択を全て解除
            const allVirtualObjects = document.querySelectorAll('.virtual-object');
            allVirtualObjects.forEach(el => {
                el.style.outline = '';
            });
            this.selectedVirtualObjects.clear();

            // 新しい選択
            this.selectedVirtualObjects.add(obj);
            element.style.outline = '2px solid #007bff';

            console.log('[VirtualObjectList] 仮身を選択:', obj.link_name);
        }
    }

    /**
     * 選択中の仮身を取得（複数選択時は最初の仮身）
     * @returns {Object|null} 選択中の仮身オブジェクト
     */
    getSelectedVirtualObject() {
        if (this.selectedVirtualObjects.size === 0) {
            return null;
        }
        // Setから最初の要素を取得
        return Array.from(this.selectedVirtualObjects)[0];
    }

    /**
     * 開いた仮身を作成（tad.jsの7827-7855行を参考）
     * @param {Object} obj - 仮身オブジェクト
     * @returns {HTMLElement} - 開いた仮身要素
     */
    createOpenedVirtualObject(obj) {
        if (!this.virtualObjectRenderer) {
            console.error('[VirtualObjectList] VirtualObjectRenderer が初期化されていません');
            return document.createElement('div');
        }

        // VirtualObjectRendererを使って開いた仮身を作成
        const options = {
            loadIconCallback: (realId) => this.loadIconFromParent(realId)
        };

        const vobj = this.virtualObjectRenderer.createOpenedBlockElement(obj, options);

        // data-link-name属性を追加（仮身識別用）
        vobj.setAttribute('data-link-name', obj.link_name);

        // コンテンツ領域を取得
        const contentArea = vobj.querySelector('.virtual-object-content-area');
        if (contentArea) {
            // 初期表示はローディングメッセージ
            contentArea.innerHTML = `<p>読み込み中...</p>`;

            // 実身データを読み込んで表示（非同期）
            this.loadAndDisplayRealObjectContent(contentArea, obj);
        }

        // クリックイベント（選択）
        vobj.addEventListener('click', (e) => {
            // 読み取り専用モードの場合は選択を無効化
            if (this.isReadonly) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();
            this.selectVirtualObject(obj, vobj, e);
            console.log('[VirtualObjectList] 開いた仮身クリック:', obj.link_name, obj.link_id);
        });

        // 位置変更機能（ドラッグ）を追加
        this.makeVirtualObjectDraggable(vobj, obj);

        // サイズ変更機能（リサイズ）を追加
        this.makeVirtualObjectResizable(vobj, obj);

        return vobj;
    }

    /**
     * 開いた仮身に実身の内容を表示
     * defaultOpenプラグインに描画を依頼する
     *
     * @param {HTMLElement} vobjElement - 開いた仮身のDOM要素
     * @param {Object} virtualObject - 仮身オブジェクト
     * @param {Object} options - オプション
     * @returns {Promise<HTMLIFrameElement>} コンテンツiframe
     */
    async expandVirtualObject(vobjElement, virtualObject, options = {}) {
        console.log('[VirtualObjectList] 開いた仮身の展開開始:', virtualObject.link_name);

        // 1. defaultOpenプラグインを取得
        const defaultOpenPlugin = this.getDefaultOpenPlugin(virtualObject);
        if (!defaultOpenPlugin) {
            console.warn('[VirtualObjectList] defaultOpenプラグインが見つかりません');
            return null;
        }
        console.log('[VirtualObjectList] defaultOpenプラグイン:', defaultOpenPlugin);

        // 2. XTADファイルを読み込む（親ウィンドウ経由）
        try {
            const xtadFile = await this.loadDataFileFromParent(virtualObject.link_id);
            const xmlData = await xtadFile.text();
            console.log('[VirtualObjectList] XTADデータ読み込み完了:', xmlData.length, '文字');

            // 3. コンテンツ領域を取得
            const contentArea = vobjElement.querySelector('.virtual-object-content-area');
            if (!contentArea) {
                console.error('[VirtualObjectList] コンテンツ領域が見つかりません');
                return null;
            }

            // コンテンツ領域のスクロールバーを非表示（noScrollbarオプション対応）
            if (options.noScrollbar !== false) {
                contentArea.style.overflow = 'hidden';
            }

            // 4. プラグインをiframeで読み込む（プラグインが描画する）
            const iframe = this.createPluginIframe(defaultOpenPlugin, virtualObject, xmlData, options);
            contentArea.appendChild(iframe);
            console.log('[VirtualObjectList] iframe追加完了');

            return iframe;
        } catch (error) {
            console.error('[VirtualObjectList] expandVirtualObject エラー:', error);
            return null;
        }
    }

    /**
     * defaultOpenプラグインを取得
     * @param {Object} virtualObject - 仮身オブジェクト
     * @returns {string|null} プラグインID
     */
    getDefaultOpenPlugin(virtualObject) {
        const applist = virtualObject.applist || {};
        for (const [pluginId, config] of Object.entries(applist)) {
            if (config && config.defaultOpen === true) {
                return pluginId;
            }
        }
        return null;
    }

    /**
     * プラグインをiframeで読み込み、描画を依頼
     * @param {string} pluginId - プラグインID
     * @param {Object} virtualObject - 仮身オブジェクト
     * @param {string} xmlData - XTADファイルの内容
     * @param {Object} options - オプション
     * @returns {HTMLIFrameElement} iframe要素
     */
    createPluginIframe(pluginId, virtualObject, xmlData, options = {}) {
        const iframe = document.createElement('iframe');
        iframe.className = 'virtual-object-content';
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.overflow = 'hidden';  // iframe要素のスクロールバーを非表示
        iframe.style.padding = '0';  // CSSのpadding: 5pxを上書き
        iframe.style.backgroundColor = options.bgcol || virtualObject.bgcol || '#ffffff';

        // プラグインのパスを取得
        const pluginPath = `../../plugins/${pluginId}/index.html`;
        iframe.src = pluginPath;

        // iframeロード後にデータを送信（load-dataメッセージ形式）
        iframe.addEventListener('load', () => {
            console.log('[VirtualObjectList] iframe読み込み完了、プラグインにload-dataメッセージ送信');
            iframe.contentWindow.postMessage({
                type: 'load-data',
                realId: virtualObject.link_id,
                realObject: {
                    records: [{
                        xtad: xmlData,
                        data: xmlData
                    }]
                },
                readonly: options.readonly !== false,
                noScrollbar: options.noScrollbar !== false,
                bgcol: options.bgcol || virtualObject.bgcol
            }, '*');
        });

        return iframe;
    }

    openVirtualObject(obj) {
        console.log('[VirtualObjectList] 仮身を開く:', obj.link_name, obj.link_id);

        // 親ウィンドウにメッセージを送信して仮身リンク先を開く
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'open-virtual-object',
                linkId: obj.link_id,
                linkName: obj.link_name
            }, '*');
        }
    }

    /**
     * 仮身要素をドラッグ可能にする（位置変更機能）
     * @param {HTMLElement} vobjElement - 仮身のDOM要素
     * @param {Object} obj - 仮身オブジェクト
     */
    makeVirtualObjectDraggable(vobjElement, obj) {
        // draggable属性を設定（クロスウィンドウドラッグ用）
        vobjElement.setAttribute('draggable', 'true');

        // ドラッグ開始（HTML5 Drag&Drop）
        vobjElement.addEventListener('dragstart', (e) => {
            // mousedownで準備したドラッグ状態を確認
            if (!this.draggingState.currentObject || !this.draggingState.isDragging) {
                console.warn('[VirtualObjectList] dragstart: ドラッグ準備ができていません');
                e.preventDefault();
                return;
            }

            // 別ウィンドウへのドロップフラグをリセット
            this.lastDropWasCrossWindow = false;

            // ドラッグ中はスクロールを無効化
            const pluginContent = document.querySelector('.plugin-content');
            if (pluginContent) {
                pluginContent.style.overflow = 'hidden';
                console.log('[VirtualObjectList] ドラッグ中: スクロールを無効化');
            }

            // ドラッグ中はすべてのiframeのpointer-eventsを無効化（開いた仮身内へのドロップを防ぐ）
            // 開いた仮身のコンテンツiframe（.virtual-object-content）を無効化
            const allIframes = document.querySelectorAll('.virtual-object-content');
            allIframes.forEach(iframe => {
                iframe.style.pointerEvents = 'none';
            });
            console.log('[VirtualObjectList] ドラッグ中: iframe pointer-events無効化 (', allIframes.length, '個)');

            console.log('[VirtualObjectList] dragstart: HTML5ドラッグ開始', obj.link_name);
            console.log('[VirtualObjectList] ドラッグ開始:', obj.link_name, 'モード:', this.draggingState.dragMode);

            // ドラッグデータを設定
            const dragData = {
                type: 'virtual-object-drag',
                source: 'virtual-object-list',
                sourceWindowId: this.windowId, // ドラッグ元ウィンドウID
                mode: this.draggingState.dragMode, // 'move' または 'copy'
                virtualObject: {
                    link_id: obj.link_id,
                    link_name: obj.link_name,
                    width: obj.width || 150,
                    height_px: obj.height_px || 30,
                    chsz: obj.chsz || 14,
                    frcol: obj.frcol || '#000000',
                    chcol: obj.chcol || '#000000',
                    tbcol: obj.tbcol || '#ffffff',
                    bgcol: obj.bgcol || '#ffffff',
                    dlen: obj.dlen || 0,
                    applist: obj.applist || {}
                }
            };

            e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
            // カスタムタイプとしてウィンドウIDを設定（dragoverで読み取れる）
            e.dataTransfer.setData('application/x-vobj-window-id', this.windowId);
            e.dataTransfer.effectAllowed = this.draggingState.dragMode === 'copy' ? 'copy' : 'move';

            // 半透明にする
            vobjElement.style.opacity = '0.5';
        });

        // ドラッグ中の位置更新（HTML5 Drag&Drop）
        // 注: 実際の位置更新は親ウィンドウからのpostMessageで行う
        vobjElement.addEventListener('drag', (e) => {
            console.log('[VirtualObjectList] drag発火:', e.clientX, e.clientY, 'currentObject:', !!this.draggingState.currentObject);

            // drag中はmousemoveが発火しないため、ここで位置を更新
            // currentObjectが設定されていればドラッグ準備完了とみなす
            if (!this.draggingState.currentObject) {
                console.log('[VirtualObjectList] drag: currentObjectなし、スキップ');
                return;
            }

            // e.clientX/Yが0の場合はスキップ（ドラッグ終了時に0,0が送られる）
            if (e.clientX === 0 && e.clientY === 0) {
                console.log('[VirtualObjectList] drag: 座標が0,0、スキップ');
                return;
            }

            const deltaX = e.clientX - this.draggingState.startX;
            const deltaY = e.clientY - this.draggingState.startY;

            // 5px以上移動したらドラッグとみなす
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                if (!this.draggingState.hasMoved) {
                    console.log('[VirtualObjectList] drag: 移動を検知 (hasMoved = true)', deltaX, deltaY);
                }
                this.draggingState.hasMoved = true;
            }

            // 親ウィンドウに現在のマウス位置を保存（handleParentDragPositionで使用）
            this.draggingState.currentDeltaX = deltaX;
            this.draggingState.currentDeltaY = deltaY;
        });

        // ドラッグ終了
        vobjElement.addEventListener('dragend', (e) => {
            vobjElement.style.opacity = '1';
            vobjElement.style.visibility = 'visible'; // 表示状態をリセット

            // ドラッグ終了時にスクロールを再有効化
            const pluginContent = document.querySelector('.plugin-content');
            if (pluginContent) {
                pluginContent.style.overflow = 'auto';
                console.log('[VirtualObjectList] ドラッグ終了: スクロールを再有効化');
            }

            // ドラッグ終了時にすべてのiframeのpointer-eventsを再有効化
            // 開いた仮身のコンテンツiframe（.virtual-object-content）を再有効化
            const allIframes = document.querySelectorAll('.virtual-object-content');
            allIframes.forEach(iframe => {
                iframe.style.pointerEvents = 'auto';
            });
            console.log('[VirtualObjectList] ドラッグ終了: iframe pointer-events再有効化 (', allIframes.length, '個)');

            console.log('[VirtualObjectList] dragend: ドラッグ終了', obj.link_name, 'dropEffect:', e.dataTransfer.dropEffect, 'crossWindow:', this.lastDropWasCrossWindow);

            // クロスウィンドウドロップの通知を待つため、少し遅延させる
            // (check-window-idメッセージがdragendより後に到着する可能性があるため)
            setTimeout(() => {
                console.log('[VirtualObjectList] dragend処理実行 (遅延後):', 'dropEffect:', e.dataTransfer.dropEffect, 'crossWindow:', this.lastDropWasCrossWindow);

                // dropEffect='copy'の場合は別ウィンドウへのドロップ成功
                // dropEffect='none'の場合はドロップ失敗（キャンセル）
                // dropEffect='move'の場合は同じウィンドウ内の移動

                if (e.dataTransfer.dropEffect === 'copy' && this.lastDropWasCrossWindow) {
                    // 別ウィンドウへのコピー: 元の仮身はそのまま残す
                    console.log('[VirtualObjectList] 別ウィンドウへのコピー: 元の仮身を保持');
                    // ドラッグ状態をリセット
                    this.draggingState.isDragging = false;
                    this.draggingState.hasMoved = false;
                    this.draggingState.currentObject = null;
                    this.draggingState.currentElement = null;
                    this.draggingState.dropClientX = undefined;
                    this.draggingState.dropClientY = undefined;
                    this.lastDropWasCrossWindow = false;
                } else if (e.dataTransfer.dropEffect === 'copy' && !this.lastDropWasCrossWindow) {
                    // 同じウィンドウ内のコピー: finishDrag()で新しい仮身を作成
                    console.log('[VirtualObjectList] 同じウィンドウ内のコピー: finishDrag()を呼び出し');
                    this.finishDrag();
                } else if (this.lastDropWasCrossWindow) {
                    // 別ウィンドウへの移動: 元の仮身を削除
                    console.log('[VirtualObjectList] 別ウィンドウへの移動: 元の仮身を削除');
                    const index = this.virtualObjects.findIndex(v => v.link_id === obj.link_id);
                    if (index !== -1) {
                        this.virtualObjects.splice(index, 1);
                        this.removeVirtualObjectFromXml(obj);
                        this.renderVirtualObjects();
                    }
                    // ドラッグ状態をリセット
                    this.draggingState.isDragging = false;
                    this.draggingState.hasMoved = false;
                    this.draggingState.currentObject = null;
                    this.draggingState.currentElement = null;
                    this.draggingState.dropClientX = undefined;
                    this.draggingState.dropClientY = undefined;
                    this.lastDropWasCrossWindow = false;
                } else if (e.dataTransfer.dropEffect === 'none') {
                    // ドロップ失敗（キャンセル）: 元の位置に戻す
                    console.log('[VirtualObjectList] ドロップキャンセル: 元の位置に戻す');
                    vobjElement.style.left = this.draggingState.initialLeft + 'px';
                    vobjElement.style.top = this.draggingState.initialTop + 'px';
                    // ドラッグ状態をリセット
                    this.draggingState.isDragging = false;
                    this.draggingState.hasMoved = false;
                    this.draggingState.currentObject = null;
                    this.draggingState.currentElement = null;
                    this.draggingState.dropClientX = undefined;
                    this.draggingState.dropClientY = undefined;
                } else {
                    // 同じウィンドウ内の移動: finishDrag()で位置を更新
                    console.log('[VirtualObjectList] 同じウィンドウ内の移動: finishDrag()を呼び出し');
                    this.finishDrag();
                }

                this.draggingState.dragMode = 'move'; // リセット
            }, 50); // 50ms遅延でcheck-window-idメッセージの到着を待つ
        });

        // 右クリックでコピーモードに切り替え
        vobjElement.addEventListener('contextmenu', (e) => {
            // 右クリックメニューは表示させたいので、ドラッグモードの切り替えのみ行う
            // ここでは何もしない（setupContextMenuで処理）
        });

        // マウスダウン時にモードを設定してドラッグ開始
        vobjElement.addEventListener('mousedown', (e) => {
            // 読み取り専用モードの場合はドラッグを無効化
            if (this.isReadonly) {
                return;
            }

            // リサイズエリア（右端8px、下端8px）かどうかをチェック
            const rect = vobjElement.getBoundingClientRect();
            const isRightEdge = e.clientX > rect.right - 8;
            const isBottomEdge = e.clientY > rect.bottom - 8;

            // リサイズエリアの場合はドラッグ処理をスキップ
            if (isRightEdge || isBottomEdge) {
                return;
            }

            if (e.button === 2) {
                // 右クリック → コピーモード
                this.draggingState.dragMode = 'copy';
                console.log('[VirtualObjectList] コピーモード設定');
            } else {
                // 左クリック → 移動モード
                this.draggingState.dragMode = 'move';
                console.log('[VirtualObjectList] 移動モード設定');
            }

            // 位置変更用の準備とドラッグ状態の開始
            this.draggingState.hasMoved = false;
            this.draggingState.currentObject = obj;
            this.draggingState.currentElement = vobjElement;
            this.draggingState.startX = e.clientX;
            this.draggingState.startY = e.clientY;
            this.draggingState.initialLeft = obj.vobjleft;
            this.draggingState.initialTop = obj.vobjtop;
            this.draggingState.isDragging = true; // dragイベントより前に設定

            console.log('[VirtualObjectList] mousedown: ドラッグ準備完了 isDragging=true', obj.link_name);
        });
    }

    /**
     * 仮身要素をリサイズ可能にする
     * @param {HTMLElement} vobjElement - 仮身のDOM要素
     * @param {Object} obj - 仮身オブジェクト
     */
    makeVirtualObjectResizable(vobjElement, obj) {
        // マウス移動でカーソルを変更（リサイズエリアの表示）
        vobjElement.addEventListener('mousemove', (e) => {
            const rect = vobjElement.getBoundingClientRect();
            const isRightEdge = e.clientX > rect.right - 16;
            const isBottomEdge = e.clientY > rect.bottom - 16;

            // カーソルの形状を変更
            if (isRightEdge && isBottomEdge) {
                vobjElement.style.cursor = 'nwse-resize'; // 右下: 斜めリサイズ
            } else if (isRightEdge) {
                vobjElement.style.cursor = 'ew-resize'; // 右: 横リサイズ
            } else if (isBottomEdge) {
                vobjElement.style.cursor = 'ns-resize'; // 下: 縦リサイズ
            } else {
                vobjElement.style.cursor = 'pointer'; // 通常: ポインタ
            }
        });

        // マウスが仮身から離れたらカーソルを元に戻す
        vobjElement.addEventListener('mouseleave', () => {
            vobjElement.style.cursor = 'pointer';
        });

        // マウスダウンでリサイズ開始
        vobjElement.addEventListener('mousedown', (e) => {
            // 読み取り専用モードの場合はリサイズを無効化
            if (this.isReadonly) {
                return;
            }

            const rect = vobjElement.getBoundingClientRect();
            const isRightEdge = e.clientX > rect.right - 16;
            const isBottomEdge = e.clientY > rect.bottom - 16;

            // リサイズエリア（右端16px、下端16px）のクリックのみ処理
            if (!isRightEdge && !isBottomEdge) {
                return;
            }

            // リサイズ中は新しいリサイズを開始しない
            if (this.isResizing) {
                console.log('[VirtualObjectList] リサイズ中のため、新しいリサイズを無視');
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            // リサイズ開始フラグを設定
            this.isResizing = true;

            // ウィンドウのリサイズハンドルを一時的に無効化
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'disable-window-resize'
                }, '*');
            }

            // リサイズモード開始
            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = rect.width;
            const startHeight = rect.height;
            const minWidth = 50;

            // chszベースの最小高さを計算
            const chsz = Math.round(obj.chsz || 14); // 浮動小数点誤差を防ぐ
            const lineHeight = 1.2;
            const chszPx = window.convertPtToPx(chsz);
            const textHeight = Math.ceil(chszPx * lineHeight);
            const minClosedHeight = textHeight + 8; // 閉じた仮身の最小高さ = タイトルエリアの高さ

            // DOMから実際のコンテンツエリアの有無で開閉状態を判定
            const hasContentArea = vobjElement.querySelector('.virtual-object-content-area') !== null ||
                                  vobjElement.querySelector('.virtual-object-content-iframe') !== null;

            // リサイズ中は閉じた仮身の最小高さまで小さくできるようにする
            const minHeight = minClosedHeight;

            console.log('[VirtualObjectList] 仮身リサイズ開始:', obj.link_name, 'startWidth:', startWidth, 'startHeight:', startHeight, 'hasContentArea:', hasContentArea, 'chsz:', chsz, 'minHeight:', minHeight);

            // リサイズプレビュー枠を作成
            const previewBox = document.createElement('div');
            previewBox.style.position = 'fixed'; // キャンバス外でも表示されるようにfixedを使用

            // 既に取得済みのrectを使用（3827行目で宣言済み）
            previewBox.style.left = `${rect.left}px`;
            previewBox.style.top = `${rect.top}px`;
            previewBox.style.width = `${startWidth}px`;
            previewBox.style.height = `${startHeight}px`;
            previewBox.style.border = '2px dashed rgba(0, 123, 255, 0.8)';
            previewBox.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
            previewBox.style.pointerEvents = 'none';
            previewBox.style.zIndex = '999999'; // さらに高いz-indexを使用
            previewBox.style.boxSizing = 'border-box';

            // document.bodyに直接追加（iframe上でも表示される）
            document.body.appendChild(previewBox);

            // 開いた仮身内のiframeのpointer-eventsを無効化（リサイズ中にマウスイベントを親に伝播させる）
            const iframe = vobjElement.querySelector('iframe');
            if (iframe) {
                iframe.style.pointerEvents = 'none';
            }

            let lastMoveEvent = null; // 最後のマウス移動イベントを保存
            let currentWidth = startWidth;
            let currentHeight = Math.max(minHeight, startHeight); // 最小高さを強制適用

            const onMouseMove = (moveEvent) => {
                lastMoveEvent = moveEvent; // 最後のイベントを保存

                if (isRightEdge) {
                    const deltaX = moveEvent.clientX - startX;
                    currentWidth = Math.max(minWidth, startWidth + deltaX);
                    previewBox.style.width = `${currentWidth}px`;
                }

                if (isBottomEdge) {
                    const deltaY = moveEvent.clientY - startY;
                    currentHeight = Math.max(minHeight, startHeight + deltaY);
                    previewBox.style.height = `${currentHeight}px`;
                }
            };

            // スロットルなしでプレビュー枠を更新（リアルタイム）
            const throttledMouseMove = onMouseMove;

            const onMouseUp = () => {
                document.removeEventListener('mousemove', throttledMouseMove);
                document.removeEventListener('mouseup', onMouseUp);

                // プレビュー枠を削除
                if (previewBox && previewBox.parentNode) {
                    previewBox.parentNode.removeChild(previewBox);
                }

                // iframeのpointer-eventsを元に戻す
                if (iframe) {
                    iframe.style.pointerEvents = 'auto';
                }

                // カーソルを元に戻す
                vobjElement.style.cursor = 'pointer';

                // 最終的なサイズを取得（プレビュー枠のサイズを使用）
                const finalWidth = Math.round(currentWidth);
                const finalHeight = Math.round(currentHeight);

                // 実際の要素のサイズを更新
                vobjElement.style.width = `${finalWidth}px`;
                vobjElement.style.height = `${finalHeight}px`;

                // 元のサイズを保存（幅のみ使用）
                const oldWidth = obj.width;

                // 仮身オブジェクトのサイズを更新
                obj.width = finalWidth;
                obj.height_px = finalHeight;
                obj.vobjright = obj.vobjleft + finalWidth;
                obj.vobjbottom = obj.vobjtop + finalHeight;

                console.log('[VirtualObjectList] 仮身リサイズ終了:', obj.link_name, 'newWidth:', finalWidth, 'newHeight:', finalHeight);

                // XMLを更新
                this.updateVirtualObjectInXml(obj);

                // 開いた仮身と閉じた仮身の判定が変わったかチェック
                const chsz = Math.round(obj.chsz || 14); // 浮動小数点誤差を防ぐ
                const lineHeight_resize = 1.2;
                const chszPx_resize = window.convertPtToPx(chsz);
                const textHeight_resize = Math.ceil(chszPx_resize * lineHeight_resize);
                const minOpenHeight = textHeight_resize + 30; // タイトルバー(textHeight+8) + 区切り線(2) + コンテンツ最小(20)
                const wasOpen = hasContentArea; // DOMベースの判定を使用
                const isNowOpen = finalHeight >= minOpenHeight;

                if (wasOpen !== isNowOpen) {
                    // 判定が変わった場合は、少し待ってから仮身要素を再作成
                    console.log('[VirtualObjectList] 開いた仮身/閉じた仮身の判定が変わりました。少し待ってから再作成します。');

                    // 既存のタイマーをクリア（連続したリサイズで最後の一回だけ実行）
                    if (this.recreateVirtualObjectTimer) {
                        clearTimeout(this.recreateVirtualObjectTimer);
                    }

                    // 新しく開いた状態になった場合、opened プロパティを明示的に設定
                    if (isNowOpen) {
                        obj.opened = true;
                    } else {
                        obj.opened = false;
                    }

                    // 遅延して再作成（150ms後）
                    // 要素への参照をクロージャでキャプチャ
                    const elementToReplace = vobjElement;
                    this.recreateVirtualObjectTimer = setTimeout(() => {
                        console.log('[VirtualObjectList] 仮身を再作成します。');

                        // 要素がまだDOMに存在するかチェック
                        if (!elementToReplace.parentNode) {
                            console.warn('[VirtualObjectList] 再作成対象の仮身要素がDOMから削除されています');
                            this.recreateVirtualObjectTimer = null;
                            return;
                        }

                        const newElement = this.createVirtualObjectElement(obj);
                        elementToReplace.replaceWith(newElement);

                        // 新しく開いた状態になった場合、コンテンツを展開
                        if (isNowOpen) {
                            this.expandVirtualObject(newElement, obj, {
                                readonly: true,
                                noScrollbar: true,
                                bgcol: obj.bgcol
                            }).catch(err => {
                                console.error('[VirtualObjectList] 展開エラー:', err);
                            });
                        }

                        this.recreateVirtualObjectTimer = null;
                    }, 150);
                }

                // キャンバスサイズを更新
                this.updateCanvasSize();

                // ウィンドウのリサイズハンドルを再有効化
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage({
                        type: 'enable-window-resize'
                    }, '*');
                }

                // リサイズ終了フラグをリセット
                this.isResizing = false;
            };

            document.addEventListener('mousemove', throttledMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    }

    /**
     * 仮身位置の変更をxmlTADに反映
     * @param {Object} obj - 仮身オブジェクト
     */
    updateVirtualObjectPosition(obj) {
        if (!this.xmlData) {
            console.warn('[VirtualObjectList] xmlDataがありません');
            return;
        }

        try {
            // XMLDocumentとして解析
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(this.xmlData, 'text/xml');

            // 対象の<link>要素を検索
            // 同じlink_idを持つ仮身が複数ある場合、元の位置情報で識別
            const links = xmlDoc.querySelectorAll('link');
            let targetLink = null;

            for (const link of links) {
                const linkId = link.getAttribute('id');
                const linkLeft = parseInt(link.getAttribute('vobjleft')) || 0;
                const linkTop = parseInt(link.getAttribute('vobjtop')) || 0;
                const linkRight = parseInt(link.getAttribute('vobjright')) || 0;
                const linkBottom = parseInt(link.getAttribute('vobjbottom')) || 0;

                // link_idと元の位置が一致する<link>を検索
                if (linkId === obj.link_id &&
                    linkLeft === obj.originalLeft &&
                    linkTop === obj.originalTop &&
                    linkRight === obj.originalRight &&
                    linkBottom === obj.originalBottom) {
                    targetLink = link;
                    console.log('[VirtualObjectList] link要素を発見:', obj.link_id, '元の位置:', obj.originalLeft, obj.originalTop);
                    break;
                }
            }

            if (!targetLink) {
                console.warn('[VirtualObjectList] link要素が見つかりません:', obj.link_id, '元の位置:', obj.originalLeft, obj.originalTop);
                return;
            }

            // 座標属性を更新
            targetLink.setAttribute('vobjleft', obj.vobjleft.toString());
            targetLink.setAttribute('vobjtop', obj.vobjtop.toString());
            targetLink.setAttribute('vobjright', obj.vobjright.toString());
            targetLink.setAttribute('vobjbottom', obj.vobjbottom.toString());

            // 元の位置情報を更新（次回の移動時に正しく識別できるように）
            obj.originalLeft = obj.vobjleft;
            obj.originalTop = obj.vobjtop;
            obj.originalRight = obj.vobjright;
            obj.originalBottom = obj.vobjbottom;

            // XMLを文字列に戻す
            const serializer = new XMLSerializer();
            this.xmlData = serializer.serializeToString(xmlDoc);

            console.log('[VirtualObjectList] xmlTAD更新完了:', obj.link_id, '新しい位置:', obj.vobjleft, obj.vobjtop);

            // 自動保存
            this.notifyXmlDataChanged();

            // スクロールバー更新を通知
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'update-scrollbars'
                }, '*');
            }

        } catch (error) {
            console.error('[VirtualObjectList] xmlTAD更新エラー:', error);
        }
    }

    /**
     * キャンバスサイズを仮身の位置に合わせて更新
     */
    updateCanvasSize() {
        const canvas = document.querySelector('.virtual-canvas');
        if (!canvas) {
            console.warn('[VirtualObjectList] キャンバス要素が見つかりません');
            return;
        }

        // 全ての仮身の最大位置を計算（virtualObjects配列から）
        let maxRight = 0;
        let maxBottom = 0;

        console.log('[VirtualObjectList] 仮身数:', this.virtualObjects.length);

        this.virtualObjects.forEach((obj, index) => {
            const right = obj.vobjright || (obj.vobjleft + (obj.width || 100));
            const bottom = obj.vobjbottom || (obj.vobjtop + (obj.height_px || 100));

            console.log(`[VirtualObjectList] 仮身${index} (${obj.link_name}): left=${obj.vobjleft}, top=${obj.vobjtop}, right=${right}, bottom=${bottom}`);

            maxRight = Math.max(maxRight, right);
            maxBottom = Math.max(maxBottom, bottom);
        });

        // マージンを追加
        maxRight += 50;
        maxBottom += 50;

        // .plugin-contentの現在のサイズ（ウィンドウの表示域）を取得
        const pluginContent = document.querySelector('.plugin-content');
        const windowWidth = pluginContent ? pluginContent.clientWidth : 300;
        const windowHeight = pluginContent ? pluginContent.clientHeight : 200;

        // コンテンツサイズとウィンドウサイズの大きい方を採用
        const finalWidth = Math.max(maxRight, windowWidth, 300);  // 最小300px
        const finalHeight = Math.max(maxBottom, windowHeight, 200); // 最小200px

        // キャンバスのwidthとheightを設定（灰色の領域を防ぐ）
        canvas.style.width = finalWidth + 'px';
        canvas.style.height = finalHeight + 'px';

        console.log('[VirtualObjectList] キャンバスサイズ更新:', finalWidth, 'x', finalHeight, '(コンテンツ:', maxRight, 'x', maxBottom, ', ウィンドウ:', windowWidth, 'x', windowHeight, ')');

        // スクロールバー更新を通知
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'update-scrollbars'
            }, '*');
        }
    }

    /**
     * 全画面表示オフ時にキャンバスサイズを縮小（必要に応じて）
     * コンテンツがウィンドウサイズより小さければ、ウィンドウサイズに合わせる
     */
    shrinkCanvasIfNeeded() {
        const canvas = document.querySelector('.virtual-canvas');
        if (!canvas) {
            console.warn('[VirtualObjectList] キャンバス要素が見つかりません');
            return;
        }

        // 全ての仮身の最大位置を計算
        let maxRight = 0;
        let maxBottom = 0;

        this.virtualObjects.forEach((obj) => {
            const right = obj.vobjright || (obj.vobjleft + (obj.width || 100));
            const bottom = obj.vobjbottom || (obj.vobjtop + (obj.height_px || 100));

            maxRight = Math.max(maxRight, right);
            maxBottom = Math.max(maxBottom, bottom);
        });

        // マージンを追加
        maxRight += 50;
        maxBottom += 50;

        // .plugin-contentの現在のサイズ（ウィンドウの表示域）を取得
        const pluginContent = document.querySelector('.plugin-content');
        const windowWidth = pluginContent ? pluginContent.clientWidth : 300;
        const windowHeight = pluginContent ? pluginContent.clientHeight : 200;

        console.log('[VirtualObjectList] shrinkCanvasIfNeeded - コンテンツ:', maxRight, 'x', maxBottom, ', ウィンドウ:', windowWidth, 'x', windowHeight);

        // コンテンツがウィンドウより小さければウィンドウサイズに縮小、大きければコンテンツサイズを維持
        const finalWidth = Math.max(maxRight, windowWidth);
        const finalHeight = Math.max(maxBottom, windowHeight);

        // キャンバスのwidthとheightを設定
        canvas.style.width = finalWidth + 'px';
        canvas.style.height = finalHeight + 'px';

        console.log('[VirtualObjectList] キャンバスサイズ調整完了:', finalWidth, 'x', finalHeight);

        // スクロールバー更新を通知
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'update-scrollbars'
            }, '*');
        }
    }

    /**
     * autoopen属性がtrueの仮身を自動的に開く
     */
    async autoOpenVirtualObjects() {
        for (const virtualObj of this.virtualObjects) {
            if (virtualObj.autoopen === 'true') {
                console.log('[VirtualObjectList] 自動起動する仮身:', virtualObj.link_id);

                // applistを確認
                const applist = virtualObj.applist;
                if (!applist || typeof applist !== 'object') {
                    console.warn('[VirtualObjectList] applistが存在しません:', virtualObj.link_id);
                    continue;
                }

                // defaultOpen=trueのプラグインを探す
                let defaultPluginId = null;
                for (const [pluginId, config] of Object.entries(applist)) {
                    if (config.defaultOpen === true) {
                        defaultPluginId = pluginId;
                        break;
                    }
                }

                if (!defaultPluginId) {
                    // defaultOpen=trueがない場合は最初のプラグインを使用
                    defaultPluginId = Object.keys(applist)[0];
                }

                if (!defaultPluginId) {
                    console.warn('[VirtualObjectList] 開くためのプラグインが見つかりません:', virtualObj.link_id);
                    continue;
                }

                // 選択中の仮身を一時的に設定
                const previousSelection = new Set(this.selectedVirtualObjects);
                this.selectedVirtualObjects.clear();
                this.selectedVirtualObjects.add(virtualObj);

                // 実身を開く
                this.executeVirtualObjectWithPlugin(defaultPluginId);

                // 選択を元に戻す
                this.selectedVirtualObjects = previousSelection;

                console.log('[VirtualObjectList] 自動起動実行:', virtualObj.link_id, 'with', defaultPluginId);
            }
        }
    }

    /**
     * xmlTADの変更を親ウィンドウに通知してファイル保存を促す
     */
    notifyXmlDataChanged() {
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'xml-data-changed',
                fileId: this.fileId,
                xmlData: this.xmlData
            }, '*');

            console.log('[VirtualObjectList] xmlTAD変更を通知, fileId:', this.fileId);
        }
    }

    /**
     * ウィンドウ設定（位置・サイズ・最大化状態）を更新
     * @param {Object} windowConfig - { pos: {x, y}, width, height, maximize }
     */
    updateWindowConfig(windowConfig) {
        if (window.parent && window.parent !== window && this.fileId) {
            window.parent.postMessage({
                type: 'update-window-config',
                fileId: this.fileId,
                windowConfig: windowConfig
            }, '*');

            console.log('[VirtualObjectList] ウィンドウ設定を更新:', windowConfig);
        }
    }

    /**
     * 実身データを読み込む
     * @param {string} realId - 実身ID
     * @returns {Promise<Object>} - 実身データ
     */
    async loadRealObjectData(realId) {
        return new Promise((resolve, reject) => {
            const messageId = `load-real-${Date.now()}-${Math.random()}`;

            const messageHandler = (e) => {
                if (e.data && e.data.messageId === messageId) {
                    window.removeEventListener('message', messageHandler);
                    if (e.data.type === 'real-object-loaded') {
                        resolve(e.data.realObject);
                    } else if (e.data.type === 'real-object-error') {
                        reject(new Error(e.data.error));
                    }
                }
            };

            window.addEventListener('message', messageHandler);

            // タイムアウト設定（5秒）
            setTimeout(() => {
                window.removeEventListener('message', messageHandler);
                reject(new Error('実身データ読み込みタイムアウト'));
            }, 5000);

            // 親ウィンドウに実身データ読み込みを要求
            window.parent.postMessage({
                type: 'load-real-object',
                realId: realId,
                messageId: messageId
            }, '*');
        });
    }

    /**
     * 開いた仮身に実身データを読み込んで表示
     * @param {HTMLElement} contentArea - コンテンツエリアのDOM要素
     * @param {Object} obj - 仮身オブジェクト
     */
    async loadAndDisplayRealObjectContent(contentArea, obj) {
        try {
            // 実身IDを抽出
            const linkId = obj.link_id;
            let realId = linkId.replace(/\.(xtad|json)$/, '');
            realId = realId.replace(/_\d+$/, '');

            console.log('[VirtualObjectList] 実身データ読み込み開始:', realId);

            // 実身データを読み込む（メタデータを含む）
            const realObjectData = await this.loadRealObjectData(realId);
            if (!realObjectData) {
                console.warn('[VirtualObjectList] 実身データの読み込みに失敗しました, realId:', realId);
                contentArea.innerHTML = `<p style="color: red;">実身データの読み込みに失敗しました</p>`;
                return;
            }

            console.log('[VirtualObjectList] 実身データ読み込み完了:', realObjectData);
            console.log('[VirtualObjectList] appList:', realObjectData.applist);

            // appListからdefaultOpenのプラグインを取得
            const appList = realObjectData.applist || {};
            let defaultOpenPlugin = null;
            
            console.log('[VirtualObjectList] appListのエントリ数:', Object.keys(appList).length);
            
            for (const [pluginId, pluginInfo] of Object.entries(appList)) {
                console.log('[VirtualObjectList] チェック中:', pluginId, pluginInfo);
                if (pluginInfo.defaultOpen === true) {
                    defaultOpenPlugin = pluginId;
                    console.log('[VirtualObjectList] defaultOpenプラグインを発見:', pluginId);
                    break;
                }
            }

            // defaultOpenプラグインが見つからない場合は基本文章編集を使用
            if (!defaultOpenPlugin) {
                console.log('[VirtualObjectList] defaultOpenプラグインが見つかりません、basic-text-editorを使用します');
                defaultOpenPlugin = 'basic-text-editor';
            }

            console.log('[VirtualObjectList] 使用するプラグイン:', defaultOpenPlugin);

            // iframeを作成してプラグインを読み込む（再帰的に仮身一覧を表示可能）
            const iframe = document.createElement('iframe');
            iframe.className = 'virtual-object-content-iframe';
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.style.overflow = 'hidden'; // スクロールバー非表示
            iframe.setAttribute('scrolling', 'no'); // スクロールバー非表示

            // プラグインのURLを設定
            const pluginUrl = `../../plugins/${defaultOpenPlugin}/index.html`;
            console.log('[VirtualObjectList] プラグインURL:', pluginUrl);
            iframe.src = pluginUrl;

            // iframeの読み込み完了時にデータを渡す
            iframe.onload = () => {
                console.log('[VirtualObjectList] iframe読み込み完了、データを送信');
                iframe.contentWindow.postMessage({
                    type: 'load-data',
                    realId: realId,
                    realObject: realObjectData,
                    readonly: true,      // 読み取り専用モード
                    noScrollbar: true    // スクロールバー非表示モード
                }, '*');
            };

            iframe.onerror = (error) => {
                console.error('[VirtualObjectList] iframe読み込みエラー:', error);
            };

            // contentAreaをクリア
            contentArea.innerHTML = '';
            contentArea.appendChild(iframe);

            console.log('[VirtualObjectList] iframeを配置しました');

        } catch (error) {
            console.error('[VirtualObjectList] 実身データ読み込みエラー:', error);
            contentArea.innerHTML = `<p style="color: red;">エラー: ${error.message}</p>`;
        }
    }
}

// DOMContentLoaded後に初期化
document.addEventListener('DOMContentLoaded', () => {
    window.virtualObjectListApp = new VirtualObjectListApp();

    // ウインドウリサイズ時にキャンバスサイズを更新
    window.addEventListener('resize', () => {
        if (window.virtualObjectListApp) {
            window.virtualObjectListApp.updateCanvasSize();
        }
    });

    // マウスホイールでのスクロールを処理
    const pluginContent = document.querySelector('.plugin-content');
    if (pluginContent) {
        pluginContent.addEventListener('wheel', (e) => {
            console.log('[VirtualObjectList] wheel イベント:', e.deltaX, e.deltaY, e.shiftKey);

            // 明示的にスクロール位置を更新
            if (e.shiftKey || Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
                // 横スクロール（Shift+ホイールまたは横ホイール）
                pluginContent.scrollLeft += e.deltaX || e.deltaY;
            } else {
                // 縦スクロール
                pluginContent.scrollTop += e.deltaY;
            }

            e.preventDefault();
        });
    }
});
